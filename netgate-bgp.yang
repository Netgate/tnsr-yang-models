module netgate-bgp {

    yang-version 1.1;

    namespace "urn:netgate:xml:yang:netgate-bgp";
    prefix "ngbgp";

    import clixon-lib {
	prefix "cl";
    }

    import ietf-inet-types {
	prefix "inet";
    }

    import ietf-yang-types {
	prefix "yang";
    }

    import netgate-frr-types {
	prefix "frr";
    }

    import netgate-frr {
	prefix "ngfrr";
    }

    import netgate-cli-extensions {
	prefix "ngcliext";
    }

    import netgate-common {
	prefix "ngcom";
    }

    import netgate-route {
	prefix "ngrt";
    }

    organization "Netgate";

    contact "Web: <http://www.netgate.com>";

    description
	"This YANG module provides a Netgate-defined data-model
	 for BGP data.

	 Copyright 2019-2025 Rubicon Communications, LLC.
	 ";

    revision 2025-06-01 {
	description
	    "TNSR Release 25.06.";
    }

    revision 2025-02-01 {
	description
	    "TNSR Release 25.02.";
    }

    revision 2024-10-02 {
	description
	    "TNSR Release 24.10.";
    }

    revision 2024-06-01 {
	description
	    "TNSR Release 24.06.";
    }

    revision 2024-02-01 {
	description
	    "TNSR Release 24.02.";
    }

    revision 2023-11-02 {
	description
	    "TNSR Release 23.11.";
    }

    revision 2023-11-01 {
	description
	    "TNSR Release 23.11.";
    }

    revision 2023-06-01 {
	description
	    "TNSR Release 23.06.";
    }

    revision 2023-02-15 {
	description
	    "TNSR Release 23.02.";
    }

    revision 2022-10-15 {
	description
	    "TNSR Release 22.10.";
    }

    revision 2022-02-15 {
	description
	    "TNSR Release 22.02.";
    }

    revision 2021-06-15 {
	description
	    "TNSR Release 21.07.";
    }

    revision 2021-02-15 {
	description
	    "TNSR Release 21.02.";
    }

    revision 2020-06-15 {
	description
	    "TNSR Release 20.06.";
    }

    revision 2020-02-15 {
	description
	    "TNSR Release 20.02.";
    }

    revision 2019-12-15 {
	description
	    "TNSR Release 19.12.";
    }

    revision 2019-08-30 {
	description
	    "TNSR Release 19.08.";
    }

    revision 2019-05-30 {
	description
	    "TNSR Release 19.05.";
    }

    typedef bgp-vrf-id {
	type ngcom:host-if-name;
    }

    typedef bgp-orf-prefix-list {
	type enumeration {
	    enum send {
		description
		"Send";
	    }
	    enum receive {
		description
		"Receive";
	    }
	    enum both {
		description
		"Both";
	    }
	}
    }

    typedef bgp-source {
	type enumeration {
	    enum kernel {
		description
		"Kernel";
	    }
	    enum connected {
		description
		"Connected";
	    }
	    enum ospf {
		description
		"OSPF";
	    }
	    enum isis {
		description
		"IS-IS";
	    }
	}
    }

    typedef community-list-value-type {
	type enumeration {
	    enum standard {
		description
		"The rules are normal numbers.";
	    }
	    enum expanded {
		description
		"The rules are regular expressions.";
	    }
	}
    }

    typedef community-list-value-size {
	type enumeration {
	    enum normal {
		description
		"Rules allow the original, normal communities values.";
	    }
	    enum extended {
		description
		"Rules allow IPv4-based policies and matches 8 octets
		     per community from RFC 5668.";
	    }
	    enum large {
		description
		"Rules allow 12-octet values from RFC 8092.";
	    }
	}
    }

    typedef community-list-action {
	type enumeration {
	    enum deny {
		description
		"Deny";
	    }
	    enum permit {
		description
		"Permit";
	    }
	}
    }

    typedef bgp-show-request {
	type enumeration {
	    enum config {
		description
		    "Configuration";
	    }
	    enum neighbors {
		description
		    "Neighbors";
	    }
	    enum network {
		description
		    "Network";
	    }
	    enum nexthop {
		description
		    "Nexthop";
	    }
	    enum peer-group {
		description
		    "Peer-group";
	    }
	    enum summary {
		description
		    "Summary";
	    }
	}
    }

    typedef bgp-show-parameter {
	type enumeration {
	    enum advertised-routes {
		description
		    "Routes advertised to BGP neighbor";
	    }
	    enum dampened-routes {
		description
		    "Dampened routes received from BGP neighbor";
	    }
	    enum detail {
		description
		    "Detail";
	    }
	    enum flap-statistics {
		description
		    "Flap statistics of the routes learned from BGP neighbor";
	    }
	    enum graceful-restart {
		description
		    "graceful-restart";
	    }
	    enum prefix-counts {
		description
		    "Detailed prefix count information";
	    }
	    enum received {
		description
		    "Information received from BGP neighbor";
	    }
	    enum received-routes {
		description
		    "Received routes from BGP neighbor";
	    }
	    enum routes {
		description
		    "Routes learned from BGP neighbor";
	    }
	}
    }

    typedef bgp-show-parameter2 {
	type enumeration {
	    enum prefix-filter {
		description
		    "Prefix-list filter";
	    }
	}
    }

    typedef bgp-ip-family {
	type enumeration {
	    enum ipv4 {
		description
		    "IPv4 address";
	    }
	    enum ipv6 {
		description
		    "IPv6 address";
	    }
	}
    }

    typedef bgp-graceful-restart-mode {
	type enumeration {
	    enum enable {
		description
		"graceful-restart enabled";
	    }
	    enum helper {
		description
		"graceful-restart helper mode";
	    }
	    enum disable {
		description
		"graceful-restart disabled";
	    }
	}
    }

    typedef bgp-role {
	type enumeration {
	    enum provider {
		description
		    "Provider";
	    }
	    enum rs-server {
		description
		    "Route Server";
	    }
	    enum rs-client {
		description
		    "Route Server Client";
	    }
	    enum customer {
		description
		    "Customer";
	    }
	    enum peer {
		description
		    "Peer";
	    }
	}
    }

    grouping bgp-ipv4-aggregations {
	description
	    "IPv4 address aggregation.";

	list aggregation {
	    key "ip-address";
	    description
		"Aggregated IP address and optional prefix";

	    ngcliext:node-fmt "^aggregate-address @{ip-address}";
	    ngcliext:post-node-fmt "$n";

	    leaf ip-address {
		type inet:ipv4-prefix;
		description
		    "Specifies aggregated adddresses as an IPv4
		     address and prefix.";
	    }

	    container aggregation-data {
		presence
		    "If present, the IPv4 prefix has
		     configured aggregation data.";

		ngcliext:children-order "as-set summary-only";

		leaf as-set {
		    type boolean;
		    description
			"Resulting routes include AS set.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "| $%";
		}

		leaf summary-only {
		    type boolean;
		    description
			"Aggregated routes will not be announced.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "| $%";
		}
	    }
	}
    }

    grouping bgp-ipv6-aggregations {
	description
	    "IPv6 address aggregation.";

	list aggregation {
	    key "ip-address";
	    description
		"Aggregated IP address and optional prefix";

	    ngcliext:node-fmt "^aggregate-address @{ip-address}";
	    ngcliext:post-node-fmt "$n";

	    leaf ip-address {
		type inet:ipv6-prefix;
		description
		    "Specifies aggregated adddresses as an IPv4
		     address and prefix.";
	    }

	    container aggregation-data {
		presence
		    "If present, the IPv6 prefix has
		     configured aggregation data.";

		leaf summary-only {
		    type boolean;
		    description
			"Aggregated routes will not be announced.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "| $%";
		}
	    }
	}
    }

    grouping bgp-ipv4-distance-admin {
	description
	    "Administrative distance specification.";

	ngcliext:node-fmt "^distance administrative @{distance}${ip-src-prefix}${access-list-name}$n";

	leaf distance {
	    type uint8;
	    description
		"The administrative distance.";
	}

	leaf ip-src-prefix {
	    type inet:ipv4-prefix;
	    description
		"The source IPv4 address and prefix.";
	    ngcliext:child-fmt " prefix @@";
	}

	leaf access-list-name {
	    type leafref {
		path "/ngrt:route-config"
		    + "/ngrt:dynamic"
		    + "/ngfrr:access-lists/ngfrr:list"
		    + "/ngfrr:name";
	    }
	    description
		"An optional Access List name.";
	    ngcliext:child-fmt " access-list @@";
	}
    }

    grouping bgp-ipv6-distance-admin {
	description
	    "Administrative distance specification.";

	ngcliext:node-fmt "^distance administrative @{distance}${ip-src-prefix}${access-list-name}$n";

	leaf distance {
	    type uint8;
	    description
		"The administrative distance.";
	}

	leaf ip-src-prefix {
	    type inet:ipv6-prefix;
	    description
		"The source IPv6 address and prefix.";
	    ngcliext:child-fmt " prefix @@";
	}

	leaf access-list-name {
	    type leafref {
		path "/ngrt:route-config"
		    + "/ngrt:dynamic"
		    + "/ngfrr:access-lists/ngfrr:list"
		    + "/ngfrr:name";
	    }
	    description
		"An optional Access List name.";
	    ngcliext:child-fmt " access-list @@";
	}
    }

    grouping bgp-distance-bgp {
	description
	    "BGP distance specification.";

	ngcliext:node-fmt "^distance ${external} ${internal} ${local}$n";

	leaf external {
	    type uint8;
	    description
		"The distance for external routes.";
	    ngcliext:child-fmt "$% @@";
	}

	leaf internal {
	    type uint8;
	    description
		"The distance for internal routes.";
	    ngcliext:child-fmt "$% @@";
	}

	leaf local {
	    type uint8;
	    description
		"The distance for local routes.";
	    ngcliext:child-fmt "$% @@";
	}
    }

    grouping bgp-multiple-path-maximums {
	description
	    "If packets should be forwarded over multiple paths, these
	     parameters specify the maximum number of paths.";

	ngcliext:parent-fmt "^maximum-paths";

	leaf non-ibgp-paths {
	    type uint8 {
		range "1..255";
	    }
	    description
		"Number of non-iBGP paths.";
	    ngcliext:node-fmt "$< @@$n";
	}

	leaf ibgp-paths {
	    type uint8 {
		range "1..255";
	    }
	    description
		"Number of iBGP paths.";
	    ngcliext:node-fmt "$< ibgp @@%{equal-cluster-length}$n";
	}

	leaf equal-cluster-length {
	    type boolean;
	    must "../ibgp-paths != ''" {
		error-message
		    "equal-cluster-length requires ibgp-paths to be set.";
	    }
	    description
		"If true, cluster lengths should match for iBGP paths.";
	    ngcliext:sibling-op "bool";
	    ngcliext:sibling-fmt "| $%";
	}
    }

    grouping bgp-neighbors {
	description
	    "Address-family-specific attributes that are per neighbor.";

	list neighbor {
	    key "peer";
	    description
		"List of neighbors within an address-family clause,
		 indexed by peer.";

	    ngcliext:node-fmt "^neighbor @{peer}$n";
	    ngcliext:pre-children-op "push";

	    leaf peer {
		type string;
		mandatory true;
		description
		    "The IPv4 or IPv6 address of the neighboring BGP
		     peer, or the name of a peer group.";
	    }

	    leaf activate {
		type boolean;
		description
		    "Enable the Address Family for this Neighbor.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    leaf addpath-tx-all-paths {
		type boolean;
		description
		    "Use addpath to advertise all paths to a neighbor.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    leaf addpath-tx-bestpath-per-as {
		type boolean;
		description
		    "Use addpath to advertise the bestpath per each
		     neighboring AS.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    container allowas-in {
		presence
		    "Enables the allowas-in clause.  One of
		     'occurences' and 'origin' may also be present.";

		ngcliext:node-op "test-set:@{occurences}@{origin}";
		ngcliext:node-fmt "^allowas-in$n|";


		description
		    "Accept an AS-path with my AS present in it.";

		leaf occurences {
		    type uint8;
		    description
			"A number in the range [1..10] giving the
			 number of occurences allowed.";
		    ngcliext:node-fmt "^allowas-in @@$n";
		}

		leaf origin {
		    type boolean;
		    description
			"If true, only accept my AS in the AS--path if
			 the route originated in my AS.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^allowas-in $%$n";
		}
	    }

	    leaf as-override {
		type boolean;
		description
		    "Override ASNs in outbound updates if as-path
		     equals remote-as.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    container attribute-unchanged {
		presence
		    "With no other leafs in this list, the presence of
		     this container indicates a bare command that
		     causes all attributes to be passed unchanged to
		     this peer.";

		description
		    "BGP attributes that are propagated unchanged to
		     this neighbor.";

		ngcliext:parent-fmt "^$%";

		leaf-list attr {
		    type string;
		    description
			"Possible attributes are: 'as-path', 'med', or
			 'next-hop'.";
		    ngcliext:node-fmt "$< @@$n";
		}
	    }

	    container capability-advertise {
		description
		    "Peer capability advertisement
		     directives.";

		leaf orf-prefix-list {
		    type bgp-orf-prefix-list;
		    description
			"One of the values 'send', 'receive', or 'both'.";
		    ngcliext:node-fmt "^capability orf prefix-list @@$n";
		}
	    }

	    container default-originate {
		presence
		    "If present, the default-originate attribute is
		     set and default routes will be announced to this
		     peer.  It also has an optional route-map.";

		ngcliext:node-fmt "^$%${route-map}$n";

		leaf route-map {
		    type leafref {
			path "/ngrt:route-config"
			    + "/ngrt:dynamic"
			    + "/ngfrr:route-maps"
			    + "/ngfrr:map"
			    + "/ngfrr:name";
		    }
		    description
			"A route map to specify criteria to originate
			 default.";
		    ngcliext:child-fmt " route-map @@";
		    }
	    }

	    leaf distribute-list-in {
		type string;
		description
		    "The name of an 'in' distribution access list used
		     to filter incoming updates.";
		ngcliext:node-fmt "^distribute-list @@ in$n";
	    }

	    leaf distribute-list-out {
		type string;
		description
		    "The name of an 'out' distribution access list
		     used to filter outgoing updates.";
		ngcliext:node-fmt "^distribute-list @@ out$n";
	    }

	    leaf filter-list-in {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:as-path-table"
			+ "/ngbgp:as-path"
			+ "/ngbgp:name";
		}
		description
		    "The name of an 'in' AS-path access-list name used
		     to filter incoming routes.";
		ngcliext:node-fmt "^filter-list @@ in$n";
	    }

	    leaf filter-list-out {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:as-path-table"
			+ "/ngbgp:as-path"
			+ "/ngbgp:name";
		}
		description
		    "The name of an 'in' AS-path access-list name used
		     to filter outgoing routes.";
		ngcliext:node-fmt "^filter-list @@ out$n";
	    }

	    container maximum-prefix {
		presence
		    "Indicates that a limited number of prefixes can be
		     accepted from this peer.";

		description
		    "The maximum number of prefixes to accept from
		     this peer, options to control a warning
		     threshold, and actions to take.  If the limit is
		     absent, none of these values will be in effect.";

		ngcliext:parent-fmt "^$%";

		leaf limit {
		    type uint32;
		    mandatory true;
		    description
			"Maximum number of prefixes to accept from
			 this peer.";
		    ngcliext:node-fmt "$< $% @@$n";
		}

		leaf warning-threshold {
		    type uint8;
		    description
			"Threshold percentage at which a marning
			 message is generate.";
		    ngcliext:node-fmt "$< threshold @@$n";
		}

		choice action-control {
		    description
			"An action to take after the limit is exceeded.";

		    leaf warning-only {
			type boolean;
			description
			    "Only issue warning messages when the limit is
			     exceeded.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf restart-interval {
			type uint16;
			description
			    "After limit is exceeded, restart BGP
			     connection.  Restart interval in minutes.";
			ngcliext:node-fmt "$< restart @@$n";
		    }
		}
	    }

	    leaf next-hop-self {
		type boolean;
		description
		    "If true, disable the next hop calculation for
		     this neighbor.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    leaf next-hop-self-force {
		type boolean;
		description
		    "If true, set the next hop to self for reflected
		     routes.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^next-hop-self force$n";
	    }

	    leaf prefix-list-in {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:prefix-lists/ngfrr:list"
			+ "/ngfrr:name";
		}
		description
		    "If present, this is the name of the 'in' prefix
		     list used to filter incoming updates.";
		ngcliext:node-fmt "^prefix-list @@ in$n";
	    }

	    leaf prefix-list-out {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:prefix-lists/ngfrr:list"
			+ "/ngfrr:name";
		}
		description
		    "If present, this is the name of the 'out' prefix
		     list used to filter outgoing updates.";
		ngcliext:node-fmt "^prefix-list @@ out$n";
	    }

	    container remove-private-as {
		presence
		    "Present if a bare 'remove-private-as' applies to
		     indicate private ASNs in outbound updates should
		     be removed.";

		ngcliext:node-op "test-set:@{all}@{replace-as}";
		ngcliext:node-fmt "^$%$n|";
		ngcliext:parent-fmt "^$%";

		leaf all {
		    type boolean;
		    description
			"Apply to all AS numbers.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|$< all$n";
		}

		leaf replace-as {
		    type boolean;
		    description
			"Replace private ASNs with our ASN in outbound
			 updates.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|$< replace-AS$n";
		}
	    }

	    leaf route-map-in {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:route-maps"
			+ "/ngfrr:map"
			+ "/ngfrr:name";
		}
		description
		    "The name of a route-map to apply to incoming
		     routes.";
		ngcliext:node-fmt "^route-map @@ in$n";
	    }

	    leaf route-map-out {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:route-maps"
			+ "/ngfrr:map"
			+ "/ngfrr:name";
		}
		description
		    "The name of a route-map to apply to outbound
		     routes.";
		ngcliext:node-fmt "^route-map @@ out$n";
	    }

	    leaf route-reflector-client {
		type boolean;
		description
		    "Configure this neighbor as a Route Reflector
		     client.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    leaf route-server-client {
		type boolean;
		description
		    "Configure this neighbor as a Route Server
		     client.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^$%$n";
	    }

	    container send-community {

		ngcliext:parent-fmt "^$%";

		description
		    "Send 'standard', 'large' or 'extended' community
		     attributes.  The default is all.";

		leaf standard {
		    type boolean;
		    default true;
		    description
			"Send standard community attributes.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|$< $%$n";
		}

		leaf large {
		    type boolean;
		    default true;
		    description
			"Send large community attributes.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|$< $%$n";
		}

		leaf extended {
		    type boolean;
		    default true;
		    description
			"Send extended community attributes.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|$< $%$n";
		}
	    }

	    leaf soft-reconfiguration-inbound {
		type boolean;
		description
		    "Allow inbound soft reconfiguration for this
		     neighbor.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|^soft-reconfiguration inbound$n";
	    }

	    leaf unsuppress-route-map {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:route-maps"
			+ "/ngfrr:map"
			+ "/ngfrr:name";
		}
		description
		    "The name of a route map to use to selectively
		     unspress otherwise suppressed routes.";
		ngcliext:node-fmt "^unsuppress-map @@$n";
	    }

	    leaf weight {
		type uint16;
		description
		    "Set default weight for routes from this
		     neighbor.";
		ngcliext:node-fmt "^$% @@$n";
	    }
	}
    }

    grouping bgp-ipv4-network-announcements {
	description
	    "This is the list of networks that will be announced to
	     each neighbor.  It is a list of IPv4 networks and
	     attributes.";

	list network {
	    key ip-prefix;
	    description
		"The list of announced networks.";

	    ngcliext:parent-fmt "^$% @{ip-prefix}";

	    leaf ip-prefix {
		type inet:ipv4-prefix;
		description
		    "The announced IPv4 prefix";
	    }

	    container announcement {
		presence
		    "If present, this network announcement is present
		     and configured.";

		ngcliext:parent-fmt "$<";
		ngcliext:node-op "test-set:@{route-map-name}@{backdoor}";
		ngcliext:node-fmt "$<$n|${route-map-name}${backdoor}";

		leaf route-map-name {
		    type leafref {
			path "/ngrt:route-config"
			    + "/ngrt:dynamic"
			    + "/ngfrr:route-maps"
			    + "/ngfrr:map"
			    + "/ngfrr:name";
		    }
		    description
			"An optional route map name used to modify
			 attributes.";
		    ngcliext:child-fmt "$< route-map @@$n";
		}

		leaf backdoor {
		    type boolean;
		    description
			"If true, this is a BGP backdoor route.";
		    ngcliext:child-op "bool";
		    ngcliext:child-fmt "|$< backdoor$n";
		}
	    }
	}
    }

    grouping bgp-ipv6-network-announcements {
	description
	    "This is the list of networks that will be announced to
	     each neighbor.  It is a list of IPv6 networks and
	     attributes.";

	list network {
	    key ip-prefix;
	    description
		"The list of announced networks.";

	    ngcliext:parent-fmt "^$% @{ip-prefix}";

	    leaf ip-prefix {
		type inet:ipv6-prefix;
		description
		    "The announced IPv6 prefix";
	    }

	    container announcement {
		presence
		    "If present, this network announcement is present
		     and configured.";

		ngcliext:parent-fmt "$<";
		ngcliext:node-op "test-set:@{route-map-name}";
		ngcliext:node-fmt "$<$n|${route-map-name}";

		leaf route-map-name {
		    type leafref {
			path "/ngrt:route-config"
			    + "/ngrt:dynamic"
			    + "/ngfrr:route-maps"
			    + "/ngfrr:map"
			    + "/ngfrr:name";
		    }
		    description
			"An optional route map name used to modify
			 attributes.";
		    ngcliext:node-fmt "$< route-map @@$n";
		}
	    }
	}
    }

    grouping bgp-imports {
	description
	    "This is the list of vrf imports and route-maps
	     used for inter-vrf route leaking.";

	list vrf-import {
	    description
		"Each import is identified by a VRF ID.";
	    key "vrf-id-import";

	    leaf vrf-id-import {
		type bgp-vrf-id;
		description
		    "Import from a custom or 'default' VRF.";

		ngcliext:node-fmt "^import vrf @@$n";
	    }
	}

	list route-map-imports {
	    description
		"Apply various route-maps to leaked routes.";
	    key "route-map-import";

	    leaf route-map-import {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngfrr:route-maps"
			+ "/ngfrr:map"
			+ "/ngfrr:name";
		}
		description
		    "A route map used to modify leaked routes.";
		ngcliext:node-fmt "^import vrf route-map @@$n";
	    }
	}
    }

    grouping bgp-redistributions {
	description
	    "Route redistribution directives.";

	ngcliext:parent-fmt "^redistribute";

	container named-sources {
	    description
		"Named, fixed source of routes that are redistributed
		 to BGP.";

	    ngcliext:parent-fmt "$<";

	    list route-source {
		key "source";
		description
		    "List of route sources that can be redistributed";

		ngcliext:parent-fmt "$< @{source}";

		leaf source {
		    type bgp-source;
		    description
			"The route source.  One of 'kernel',
			 'connected', 'ospf', 'isis'.";
		}

		container route-data {
		    presence
			"If present, this redistribution is present
			 and configured.";

		    ngcliext:parent-fmt "$<";
		    ngcliext:node-op "test-set:@{metric}@{route-map}";
		    ngcliext:node-fmt "$<$n|${metric}${route-map}";

		    leaf metric {
			type uint32;
			description
			    "Metric for redistributed
			     routes.";
			ngcliext:child-fmt "$< metric @@$n";
		    }

		    leaf route-map {
			type leafref {
			    path "/ngrt:route-config"
				+ "/ngrt:dynamic"
				+ "/ngfrr:route-maps"
				+ "/ngfrr:map"
				+ "/ngfrr:name";
			}
			description
			    "Route map for
			     redistributed routes";
			ngcliext:child-fmt "$< $% @@$n";
		    }
		}
	    }
	}
    }


    rpc bgp-show {
	input {
	    leaf vrf-id {
		type bgp-vrf-id;
		default "default";
		description
		    "Each router is identified using the name of
		     a VRF, or the word 'default'.";
	    }
	    leaf request {
		type bgp-show-request;
		description
		    "A BGP show request type.  One of the strings
		     'config', 'running', 'summary', 'peer-group',
		     'nexthop', 'network', or 'neighbor'.";
	    }
	    leaf peer {
		type string;
		description
		    "A BGP peer name or IP address.";
	    }
	    leaf net {
		type string;
		description
		    "Network or prefix.";
	    }
	    leaf param {
		type bgp-show-parameter;
		description
		    "An additional parameter string.  One of the strings
		     'advertised-routes', 'dampened-routes',
		     'detail',
		     'flap-statistics',
		     'graceful-restart',
		     'prefix-counts', 'received', 'received-routes',
		     or 'routes'.";
	    }
	    leaf param2 {
		type bgp-show-parameter2;
		description
		    "An additional parameter string.  One of the strings
		     'prefix-filter'.";
	    }
	    leaf family {
		type bgp-ip-family;
		description
		    "IP family";
	    }
	}
	output {
	    leaf stdout {
		type string;
	    }
	}
    }

    rpc bgp-clear {
	input {
	    leaf vrf-id {
		type bgp-vrf-id;
		default "default";
		description
		    "Each router is identified using the name of
		     a VRF, or the word 'default'.";
	    }
	    leaf peer {
		type string;
		description
		    "A BGP peer AS, IP address or * for all.";
	    }
	    leaf soft {
		type boolean;
		description
		    "Soft reconfiguration.";
	    }
	}
	output {
	    leaf stdout {
		type string;
	    }
	}
    }

    augment "/ngrt:route-config/ngrt:dynamic" {

	container bgp {

	    ngcliext:node-fmt "route dynamic bgp$n";
	    ngcliext:pre-children-op "push";

	    container global-options {
		description
		    "These are options that apply to the BGP Server or
		     to all BGP Router configurations.";

		ngcliext:context "bgp-config";
		ngcliext:parent-fmt "^option";

		container debug {
		    description
			"BGP debug options.";

		    ngcliext:parent-fmt "$< $%";

		    container as4 {
			description
			    "AS4 debug action.";

			ngcliext:parent-fmt "$< $%";

			leaf all {
			    type boolean;
			    description
				"If true, debug AS4 actions.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$<$n";
			}

			leaf segment {
			    type boolean;
			    description
				"If true, debug AS4 AS-path segment handling.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$< $%$n";
			}
		    }

		    container bestpath {
			description
			    "bestpath debug action.";

			ngcliext:parent-fmt "$< $%";

			container ipv4-prefixes {
			    ngcliext:parent-fmt "$<";

			    leaf-list ipv4-prefix {
				type inet:ipv4-prefix;
				description
				    "Debug bestpath of this IPv4 prefix.";
				ngcliext:node-fmt "$< @@$n";
			    }
			}

			container ipv6-prefixes {
			    ngcliext:parent-fmt "$<";

			    leaf-list ipv6-prefix {
				type inet:ipv6-prefix;
				description
				    "Debug bestpath of this IPv6 prefix.";
				ngcliext:node-fmt "$< @@$n";
			    }
			}
			leaf ipv6-prefix {
			    type inet:ipv6-prefix;
			    description
				"Debug bestpath of this IPv6 prefix.";
			    ngcliext:node-fmt "$< @@$n";
			}
		    }

		    container keepalive {
			description
			    "Debug BGP neighbor keepalive.";

			ngcliext:parent-fmt "$< $%";

			leaf all {
			    type boolean;
			    description
				"Enable BGP neighbor keepalive debug.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$<$n";
			}

			leaf peer {
			    type string;
			    description
				"Debug specific BGP neighbor.";
			    ngcliext:node-fmt "$< @@$n";
			}
		    }

		    container neighbor-events {
			description
			    "Debug BGP neighbor events.";

			ngcliext:parent-fmt "$< $%";

			leaf all {
			    type boolean;
			    description
				"Enable BGP neighbor events debug.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$<$n";
			}

			leaf peer {
			    type string;
			    description
				"Debug specific BGP neighbor.";
			    ngcliext:node-fmt "$< @@$n";
			}
		    }

		    leaf nht {
			type boolean;
			description
			    "If true, enable next hop tracking events.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf update-groups {
			type boolean;
			description
			    "If true, update-groups.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$< $%$n";
		    }

		    container updates {
			description
			    "Debug BGP neighbor events.";

			ngcliext:parent-fmt "$< $%";

			leaf all {
			    type boolean;
			    description
				"Debug BGP updates.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$<$n";
			}

		        container in-peers {
			    description
				"Debug BGP neighbor in-peers updates.";

			    ngcliext:parent-fmt "$< in";

			    leaf-list peer {
				type string;
				description
				    "Debug specific BGP neighbor in-updates.";
				ngcliext:node-fmt "$< @@$n";
			    }
			}

		        container out-peers {
			    description
				"Debug BGP neighbor out-peers updaets.";

			    ngcliext:parent-fmt "$< out";

			    leaf-list peer {
				type string;
				description
				    "Debug specific BGP neighbor out-updates.";
				ngcliext:node-fmt "$< @@$n";
			    }
			}

		        container prefixes {
			    description
				"Debug BGP neighbor prefixes updates.";

			    ngcliext:parent-fmt "$< prefix";

			    leaf-list prefix {
				type inet:ip-prefix;
				description
				    "Debug specific BGP IPv4 or IPv6 prefix.";
				ngcliext:node-fmt "$< @@$n";
			    }
			}
		    }

		    container zebra {
			description
			    "Debug BGP Zebra messages.";

			ngcliext:parent-fmt "$< $%";

			leaf all {
			    type boolean;
			    description
				"Debug BGP Zebra messages.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$<$n";
			}

			leaf prefix {
			    type inet:ip-prefix;
			    description
				"Debug specific BGP IPV4 or IPv6 prefix.";
			    ngcliext:node-fmt "$< $% @@$n";
			}
		    }
		}

		leaf enable {
		    type boolean;
		    default false;
		    description
			"If true, the BGP Daemon is enabled.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "^disable$n|^enable$n";
		    must "current() = 'false' or not(../../../ngfrr:unmanaged)" {
			error-message
			    "BGP configuration is not compatible " +
			    "with unmanaged dynamic routing configuration.";
		    }
		}

		leaf route-map-delay-timer {
		    type uint16 {
			range "0..600";
		    }
		    description
			"The delay time in seconds before processing
			 route-map changes.";
		    ngcliext:node-fmt "^route-map delay-timer @@$n";
		}
	    }

	    container routers {
		description
		    "Table of BGP Router instances index by ASN.";

		ngcliext:context "bgp-config";

		list router {
		    key "vrf-id";
		    description
			"Each router is identified using its VRF ID.";

		    ngcliext:node-fmt "^server vrf @{vrf-id}$n";
		    ngcliext:pre-children-op "push";

		    leaf vrf-id {
			type bgp-vrf-id;
			description
			    "The Virtual Routing and Forwrding ID,
			     Each router is identified using the name of
			     a VRF, or the word 'default'.";
		    }

		    leaf asn {
			type uint32 {
			    range "1..4294967295";
			}
			mandatory true;
			description
			    "The BGP Router AS number.";
			ngcliext:node-fmt "^as-number @@$n";
		    }

		    container neighbors {
			description
			    "Table of BGP Neighbors.";

			ngcliext:children-top-sort "peer-group-name-ts";

			list neighbor {
			    key "peer";
			    description
				"List of neighbors indexed by peer.";

			    ngcliext:node-fmt "^$% @{peer}$n";
			    ngcliext:pre-children-op "push";

			    leaf peer {
				type string;
				mandatory true;
				description
				    "The IPv4 or IPv6 address of the
				     neighboring BGP peer, or the name of
				     a peer group.";
			    }

			    leaf advertisement-interval {
				type uint16;
				description
				    "The minimum time in seconds
				     between sending BGP routing
				     updates to this peer.";
				ngcliext:node-fmt "^$% @@$n";
			    }

			    leaf bfd {
				type boolean;
				description
				    "Bidirectional Forwarding Detection (BFD)
				     is enabled for this peer.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$% enabled @@$n";
			    }

			    container capability-advertise {
				description
				    "This is the set of capabilities that
				     are advertised to this neighbor.";

				ngcliext:parent-fmt "^capability";

				leaf dynamic {
				    type boolean;
				    description
					"If true, advertise dynamic capability
					 to this neighbor.";
				    ngcliext:node-op "bool";
				    ngcliext:node-fmt "|$< $%$n";
				}

				leaf extended-nexthop {
				    type boolean;
				    description
					"If true, advertise extended
					 next-hop capability to this
					 neighbor.";
				    ngcliext:node-op "bool";
				    ngcliext:node-fmt "|$< $%$n";
				}
			    }

			    leaf capability-negotiate {
				type boolean;
				default true;
				description
				    "Should neighbor capabilities be
				    negotiated?.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "^dont-capability-negotiate$n|";
			    }

			    leaf description {
				type ngcom:description-63;
				description
				    "A user description of the neighbor.";
				ngcliext:node-fmt "^$% @@$n";
			    }

			    leaf disable-connected-check {
				type boolean;
				description
				    "If true, disable one-hop away EBGP
				     peer using loopback address.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    choice hops-control {
				description
				    "Options to control allowed hops between
				     this router and the neighbor.";

				container ebgp-multihop {
				    presence
					"Allow eBGP neighbors not on directly
					 connected netowrks.";
				    description
					"Control multi-hop neighbors.";

				    ngcliext:node-fmt "^$%${max-hop-count}$n";

				    leaf max-hop-count {
					type uint8;
					description
					    "Allow neighbors to be
					     multi-hop distant.  Mutually
					     exclusive with 'ttl
					     security'.";
					ngcliext:child-fmt " hop-maximum @@";
				    }
				}

				leaf ttl-security-hops {
				    type uint8 {
					range "1..254";
				    }
				    description
					"Limit neighbors to being exactly
					 <n-hops> distant.  Mutually exclusive
					 with the 'ebgp-multihop' option.";
				    ngcliext:node-fmt "^ttl-security hops @@$n";
				}
			    }

			    leaf enforce-first-as {
				type boolean;
				description
				    "Enforce the first AS for eBGP routes.";
				default true;
				ngcliext:node-op "bool";
				ngcliext:node-fmt "^no $%$n|";
			    }

			    /* bgp neighbor peer local-as-number, -prepend, and -replace-as should be containerized */
			    leaf local-as-number {
				type uint32 {
				    range "1..4294967295";
				}
				must ". != ../../../asn" {
				    error-message
				        "The local-as must not match the"
					+ " router AS number.";
				    description
				        "The local-as must not match the
					 router AS number.";
				}
				description
				    "If present, this value is an alternate
				     AS-number for this BGP instance.
				     Valid for only eBGP peers.
				     Must not match the router AS number.";
				ngcliext:node-fmt "^local-as @@%{local-as-no-prepend}$n";
			    }

			    leaf local-as-no-prepend {
				type boolean;
				description
				    "If true, don't prepend the local-as
				     to the received AS_PATH.
				     Valid for only eBGP peers.";
				ngcliext:sibling-op "bool";
				ngcliext:sibling-fmt "| no-prepend%{local-as-replace-as}";
			    }

			    leaf local-as-replace-as {
				type boolean;
				description
				    "If true, then only the supplied local-as
				     is prepended to the AS_PATH when
				     transmitting local-route updates.
				     Valid for only eBGP peers.";
				ngcliext:sibling-op "bool";
				ngcliext:sibling-fmt "| replace-as";
			    }

			    container roles {
				description
				    "BGP Role for defining peering relationships.";
				ngcliext:post-child-fmt "$n";

				leaf local-role {
				    type bgp-role;
				    must "../../remote-asn != ../../../../asn" {
				   	 error-message "BGP role may only be set for external ASNs";
				    }
				    description
					"The local BGP Role for this neighbor.";
				    ngcliext:node-fmt "^local-role @@";
				}

				leaf strict-mode {
				    type empty;
				    must "../local-role != ''" {
					error-message
					    "strict-mode requires local-role to be set.";
				    }
				    description
					"If present, BGP peering is in strict mode.";
				    ngcliext:node-fmt " strict-mode";
				}
			    }

			    leaf override-capability {
				type boolean;
				description
				    "A neighbor attribute.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    leaf passive {
				type boolean;
				description
				    "If true, don't send open messages to
				     this neighbor.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    leaf password {
				type string {
				    length "1..63";
				}
				description
				    "The neighbor password.";
				ngcliext:node-fmt "^$% @@$n";
			    }

			    leaf peer-group-name {
				type string;
				description
				    "If present, this is the name of a peer
				     group template from which attributes are
				     obtained for this neighbor.";
				ngcliext:node-fmt "^peer-group @@$n";
			    }

			    leaf port {
				type uint16;
				description
				    "IP Port.";
				ngcliext:node-fmt "^$% @@$n";
			    }

			    leaf remote-asn {
				type uint32 {
				    range "1..4294967295";
				}
				description
				    "The AS-number of the neighbor.";
				ngcliext:node-fmt "^remote-as @@$n";
			    }

			    leaf enable {
				type boolean;
				description
				    "If true, the neighbor interface
				    is enabled.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    leaf solo {
				type boolean;
				description
				    "If true, the neighbor is part of its
				     own update group.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    leaf strict-capability-match {
				type boolean;
				description
				    "Capabilites should be matched strictly.";
				ngcliext:node-op "bool";
				ngcliext:node-fmt "|^$%$n";
			    }

			    container timers {
				description
				    "Various FSM timers per neighbor.";

				ngcliext:parent-fmt "^$%";

				leaf connect {
				    type uint16;
				    description
					"BGP Connection timer.";
				    ngcliext:node-fmt "$< connect @@$n";
				}

				leaf keep-alive {
				    type uint16;
				    description
					"Keepalive interval in
					 seconds. Default is 1/3 of the
					 hold-time value.";
				    ngcliext:node-fmt "$< $% @@%{hold-time}$n";
				}

				leaf hold-time {
				    type uint16;
				    description
					"Hold-time in seconds. Default 90
					 seconds, maybe.";
				    ngcliext:sibling-fmt " $% @@";
				}
			    }

			    leaf update-source {
				type string;
				description
				    "The source from which updates will come.
				     It is either an if-name or ipv4-address.";
				ngcliext:node-fmt "^$% @@$n";
			    }

                            container graceful-restart {
                                presence
                                    "Allows to set individual values.";
                                description
				    "Graceful-restart per peer settings";

				ngcliext:parent-fmt "$%";

                                leaf mode {
                                    description
                                        "Select BGP graceful-restart per peer
                                         mode of operation.";

				    type bgp-graceful-restart-mode;
				    ngcliext:node-fmt "^$< @@$n";
                                }
                            }
			}
		    }

		    leaf allow-martian-nexthop {
			type boolean;
			description
			    "If true, allow martian next hops.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf always-compare-med {
			type boolean;
			description
			    "Always compare the Multi-exit-discriminator.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf bestpath-as-path-multipath-relax {
			type boolean;
			description
			    "Best path decisions shoul<d consider paths of
			     equal AS-path length candidates for multipath
			     computation.  Allow load sharing on routes with
			     different AS-paths of the same length.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^bestpath as-path multipath-relax$n";
		    }

		    leaf bestpath-as-path-multipath-relax-as-set {
			type boolean;
			description
			    "If true, generate an AS-set.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^bestpath as-path multipath-relax as-set$n";
		    }

		    leaf bestpath-as-path-confed {
			type boolean;
			description
			    "Best path decisions should be based on the length
			     of confederation path sets.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^bestpath as-path confed$n";
		    }

		    leaf bestpath-as-path-ignore {
			type boolean;
			description
			    "Best path decisions should ignore AS-path
			    lengths.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^bestpath as-path ignore$n";
		    }

		    leaf bestpath-compare-routerid {
			type boolean;
			description
			    "Break otherwise equal route ties using
			    router id.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^bestpath compare-routerid$n";
		    }

		    container bestpath-med {

			ngcliext:parent-fmt "^bestpath med";

			leaf confed {
			    type boolean;
			    description
				"Compare MED attribute among confederation
				 paths.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$< $%$n";
			}

			leaf missing-as-worst {
			    type boolean;
			    description
				"Treat a missing MED attribute as the
				 least preferred value.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|$< $%$n";
			}
		    }

		    leaf client-to-client-reflection {
			type boolean;
			description
			    "Allow client-to-client route reflection.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^client-to-client reflection$n";
		    }

		    leaf cluster-id {
			type union {
			    type inet:ipv4-address-no-zone;
			    type uint32;
			}
			description
			    "The route-reflector cluster id expressed as
			     either an IPv4 address or an unsigned 32-bit
			     integer.";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    leaf coalesce-time {
			type uint32;
			description
			    "Subgroup coalesce timer in ms.";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    container confederation {

			ngcliext:parent-fmt "^$%";

			description
			    "Confederation Parameters.";

			leaf identifier {
			    type uint32;
			    description
				"The confederation identifier; an AS number.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			container peers {

			    ngcliext:parent-fmt "$<";

			    leaf-list peer {
				type uint32 {
				    range "1..4294967295";
				}
				description
				    "A list of AS numbers for each peer.";
				ngcliext:node-fmt "$< $% @@$n";
			    }
			}
		    }

		    container dampening {
			description
			    "Route flap dampening parameters.";

			ngcliext:node-fmt "^dampening";
			ngcliext:post-node-fmt "$n";
			ngcliext:children-order "penalty-half-life route-reuse";

			presence
			    "If present, the route-flag dampening is
			     configured.";

			leaf penalty-half-life {
			    type uint8 {
				range "1..45";
			    }
			    description
				"The penalty half-life value [1-45].";
			    ngcliext:node-fmt " penalty @@";
			}

			leaf route-reuse {
			    type uint16 {
				range "1..20000";
			    }
			    description
				"The route reuse start value.";
			    ngcliext:node-fmt " reuse @@ %{route-suppression} %{route-suppression-maximum}";
			}

			leaf route-suppression {
			    type uint16 {
				range "1..20000";
			    }
			    description
				"The route suppression start value.";
			    ngcliext:sibling-fmt "suppress @@";
			}

			leaf route-suppression-maximum {
			    type uint8;
			    description
				"The route suppression maximum value.";
			    ngcliext:sibling-fmt "maximum @@";
			}
		    }

		    container defaults {
			description
			    "Default configuration parameters.";

			leaf ipv4-unicast-enabled {
			    type boolean;
			    default true;
			    description
				"Propagate IPv4 unicast routes.  If true,
				 routes are propagated.  If false, IPv4
				 unicast routes propagation is disabled.
				 Default true.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "^no $%$n|";
			}
		    }

		    leaf deterministic-med {
			type boolean;
			description
			    "Always produce deterministic route-selection by
			     picking the best MED path advertised from the
			     neighboring AS.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf disable-ebgp-connected-route-check {
			type boolean;
			description
			    "Disable checking if nexthop is connected an
			     eBGP session";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf ebgp-requires-policy {
			type boolean;
			default true;
			description
			    "If true, BGP speakers following RFC8212 do not use
			     or send routes on eBGP sessions, unless
			     specifically configured to do so.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "^no $%$n|";
		    }

		    leaf listen-limit {
			type uint16 {
			    range "1..5000";
			}
			description
			    "The maximum number of dynamic neighbors that
			     can be created.";
			ngcliext:node-fmt "^listen limit @@$n";
			ngcliext:node-fmt "^listen limit @@$n";
		    }

		    leaf listen-range {
			type string;
			description
			    "An IPv4 or IPv6 prefix range on which listening
			     for dynamic neighbors will take place.";
			ngcliext:node-fmt "^listen range @@%{listen-peer-group-name}$n";
		    }

		    leaf listen-peer-group-name {
			type string;
			description
			    "The peer group name for dynamically created
			     neighbors.";
			ngcliext:sibling-fmt " peer-group @@";
		    }

		    leaf log-neighbor-changes {
			type boolean;
			description
			    "Log neighbor up, down, and reset reasons.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    container max-med {

		        ngcliext:parent-fmt "^$%";

			container administrative {
			    presence
				"If present without a specific value,
				 administratively advertise routes with
				 maximum MED for an indefinite period.";

			    ngcliext:node-fmt "$< $%";
			    ngcliext:post-node-fmt "$n";

			    leaf med-value {
				type uint32;
				description
				    "The maximum MED value to use.";
				ngcliext:node-fmt " @@";
			    }
			}

			container on-startup {

			    ngcliext:parent-fmt "$< $%";
			    ngcliext:children-order "time-period";

			    leaf time-period {
				type uint32;
				description
				    "The time period, in seconds, for
				    max-med.";
				ngcliext:node-fmt "$< @@%{med-value}$n";
			    }

			    leaf med-value {
				type uint32;
				description
				    "The max MED value is effective on
				     startup, and has this time period
				     in seconds.";
				ngcliext:sibling-fmt " @@";
			    }
			}
		    }

		    leaf network-import-check {
			type boolean;
			default true;
			description
			    "If true, check if BGP network route exists
			     in IGP.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "^no network import-check$n|";
		    }

		    leaf route-reflector-allow-outbound-policy {
			type boolean;
			description
			    "If true, also allow attribure modifications to
			     the route-map-out policy.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^route-reflector allow-outbound-policy$n";
		    }

		    leaf router-id {
			type yang:dotted-quad;
			description
			    "Dotted-quad Id of the router.  Can be any 32-bit
			     unsigned value in dotted-quad format but
			     is usually the IP address of the router.
			     RFC4271 Section 4.2";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    container timers {
			description
			    "Various FSM timers.";

			ngcliext:parent-fmt "^$%";
			ngcliext:children-order "keep-alive";

			leaf keep-alive {
			    type uint16;
			    description
				"Keepalive interval in seconds. Default is 1/3
				 of the hold-time value.";
			    ngcliext:node-fmt "$< $% @@%{hold-time}$n";
			}

			leaf hold-time {
			    type uint16;
			    description
				"Hold-time in seconds. Default 90
				seconds, maybe.";
			    ngcliext:sibling-fmt " $% @@";
			}
		    }

		    leaf update-delay-updates {
			type uint16 {
			    range "0..3600";
			}
			description
			    "Force initial delay, [0..3600] seconds, for
			     best-path and updates.  Default 120 seconds.";
			ngcliext:node-fmt "^update-delay @@%{update-delay-peer-wait}$n";
		    }

		    leaf update-delay-peer-wait {
			type uint16 {
			    range "1..3600";
			}
			/* this checks the message and NOT the database!
			must "current() <= ../update-delay-updates" {
			    error-message
			        "The peer-wait delay must not be more "
				+ "than the maximum update-delay.";
			    description
				"The peer-wait delay must not be more
				 than the maximum update-delay.";
			}
			*/
			description
			    "Time to wait for a peer to establish connection.
			     Must not be greater than initial, maximum delay.
			     Default 120 seconds.";
			ngcliext:sibling-fmt " peer-wait @@";
		    }

		    leaf write-quanta {
			type uint16;
			description
			    "The number of packets to write to peer sockets
			     per update.  Default 10 packets.";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    container graceful-restart {
			description
			    "Graceful-restart specific settings.";
			ngcliext:parent-fmt "graceful-restart";

			leaf notification {
			    type boolean;
			    default true;
			    description
				"Support for BGP NOTIFICATION messages.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$< $%$n";
			}

			leaf preserve-fw-state {
			    type boolean;
			    description
				"Whether preserve the forwarding state
				 for routes or not.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$< $%$n";
			}

			leaf restart-time {
			    type uint16 {
				range "0..4095";
			    }
			    description
				"This is the estimated time (in seconds) it
				 will take for the BGP session to be
				 re-established after a restart. FRR's default is 120";
			    ngcliext:node-fmt "^$< $% @@$n";
			}

			leaf rib-stale-time {
			    type uint16 {
				range "1..3600";
			    }
			    description
				"The time the stale routes are kept in RIB.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}

			leaf select-defer-time {
			    type uint16 {
				range "0..3600";
			    }
			    description
				"Max time for the router to defer route selection
				 after restart.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}

			leaf stalepath-time {
			    type uint16 {
				range "1..4095";
			    }
			    description
				"The max time (in seconds) to hold onto restarting
				 peers stale paths";
			    ngcliext:node-fmt "^$< $% @@$n";
			}

			leaf mode {
			    type bgp-graceful-restart-mode;
			    description
				"Select BGP graceful-restart global
				 mode of operation.";

			    ngcliext:node-fmt "^$< @@$n";
			}
		    }

		    container long-lived-graceful-restart {
			description
			    "Long-lived Graceful Restart settings.";
			ngcliext:parent-fmt "long-lived-graceful-restart";

			leaf stale-time {
			    type uint32 {
				range "0..16777215";
			    }
			    description
				"The max time to wait before purging long-lived stale
				 routes for helper routers. Value of 0 means
				 the feature is off. This is default.
				 Only graceful restart mode is affected.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}
		    }

		    container address-families {
			description
			    "Address-family specific information.";

			ngcliext:parent-fmt "^address-family";

			container ipv4 {
			    description
				"Address family IPv4 configuration.";

			    ngcliext:parent-fmt "$< $%";

			    container multicast {
				description
				    "Address family IPv4-multicast
				     configuration.";

				ngcliext:node-fmt "$< $%$n";
				ngcliext:pre-children-op "push";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv4-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv4-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv4-network-announcements;
				}

				leaf table-map {
				    type leafref {
					path "/ngrt:route-config"
					    + "/ngrt:dynamic"
					    + "/ngfrr:route-maps"
					    + "/ngfrr:map"
					    + "/ngfrr:name";
				    }
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				    ngcliext:node-fmt "^$% @@$n";
				}
			    }

			    container unicast {
				description
				    "Address family IPv4-unicast
				     configuration.";

				ngcliext:node-fmt "$< $%$n";
				ngcliext:pre-children-op "push";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv4-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv4-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container multiple-path-maximums {
				    description
					"Multi-path maximums.";

				    uses bgp-multiple-path-maximums;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv4-network-announcements;
				}

				container network-imports {
				    description
					"Network imports.";

				    uses bgp-imports;
				}

				container redistributions {
				    description
					"Route redistributions.";

				    uses bgp-redistributions;
				}

				leaf table-map {
				    type leafref {
					path "/ngrt:route-config"
					    + "/ngrt:dynamic"
					    + "/ngfrr:route-maps"
					    + "/ngfrr:map"
					    + "/ngfrr:name";
				    }
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				    ngcliext:node-fmt "^$% @@$n";
				}
			    }
			}

			container ipv6 {
			    description
				"Address family IPv6 configuration.";

			    ngcliext:parent-fmt "$< $%";

			    container multicast {
				description
				    "Address family IPv6-multicast
				     configuration.";

				ngcliext:node-fmt "$< $%$n";
				ngcliext:pre-children-op "push";

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv6-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv6-network-announcements;
				}
			    }

			    container unicast {
				description
				    "Address family IPv6-unicast
				     configuration.";

				ngcliext:node-fmt "$< $%$n";
				ngcliext:pre-children-op "push";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv6-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv6-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container multiple-path-maximums {
				    description
					"Multi-path maximums.";

				    uses bgp-multiple-path-maximums;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv6-network-announcements;
				}

				container network-imports {
				    description
					"Network imports.";

				    uses bgp-imports;
				}

				container redistributions {
				    description
					"Route redistributions.";

				    uses bgp-redistributions;
				}

				leaf table-map {
				    type leafref {
					path "/ngrt:route-config"
					    + "/ngrt:dynamic"
					    + "/ngfrr:route-maps"
					    + "/ngfrr:map"
					    + "/ngfrr:name";
				    }
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				    ngcliext:node-fmt "^$% @@$n";
				}
			    }
			}
		    }
		}
	    }

	    container as-path-table {
		description
		    "Table of AS Paths, indexed by name.  Each entry
		     contains a single regular expression pattern.";

		ngcliext:node-fmt "route dynamic bgp$n";
		ngcliext:pre-children-op "push";
		ngcliext:context "as-path-config";

		list as-path {
		    key "name";
		    description
			"AS Path name.";

		    ngcliext:node-fmt "^as-path @{name}$n";
		    ngcliext:pre-children-op "push";

		    leaf name {
			type string;
			mandatory true;
			description
			    "The AS Path name as supplied by the developer.
			     It is a unique name used to identify this
			     regular expression pattern.";
		    }

		    container patterns {
			description
			    "Each AS Path can have multiple, ordered
			     policy and regular expression patterns pairs.";

			list pattern {
			    key sequence;
			    description
				"The set of ordered patterns and policy pairs
				 for an AS-path.";

			    ngcliext:node-fmt "^rule @{sequence} @{policy} @{regex}$n";

			    unique "regex";

			    leaf sequence {
				type uint32;
				description
				    "Pattern order is explicitly managed.";
			    }

			    leaf policy {
				type frr:as-path-policy;
				description
				    "One of the policies 'deny', 'permit'.";
			    }

			    leaf regex {
				type string;
				description
				    "The AS Path regular expression pattern.";
			    }
			}
		    }
		}
	    }

	    container community-lists {
		description
		    "Table of Community Lists, indexed by name.	 Each entry
		     contains a set of rules ordered by sequence number.";

		ngcliext:node-fmt "route dynamic bgp$n";
		ngcliext:pre-children-op "push";
		ngcliext:context "community-lists-config";

		list community {
		    key "name";
		    description
			"Community List entries indexed by name.";

		    ngcliext:node-fmt "^community-list @{name}${value-size}$n";
		    ngcliext:pre-children-op "push";

		    leaf name {
			type string;
			mandatory true;
			description
			    "The Community List name as supplied by
			     the developer.  It is a unique name used
			     to identify this set of Community List
			     Rules.";
		    }

		    leaf description {
			type ngcom:description-63;
			description
			    "A user description of the community list.";
			ngcliext:node-fmt "^$% @@$n";
			cl:ignore-compare;
		    }

		    leaf value-type {
			type community-list-value-type;
			description
			    "One of 'standard' or 'expanded'.
			     If 'standard' the rules are normal numbers.
			     If 'expanded', the rules are regular
			     expressions.";
			ngcliext:sibling-fmt " @@ ";
		    }

		    leaf value-size {
			type community-list-value-size;
			default "normal";
			description
			    "Optionally one of 'normal', 'extended' or 'large'.
			     When 'normal', the default, rules allow
			     the original, normal communities values.
			     When 'extended', rules allow IPv4-based policies
			     and matches 8 octets per community from RFC 5668.
			     When 'large', rules allow 12-octet values
			     from RFC 8092.";
			ngcliext:child-fmt "%{value-type}@@";
		    }

		    container rules {
			description
			    "Community List Rule Table ordered by sequence
			     number.";

			list rule {
			    key "sequence";
			    description
				"A set of Community List Rules.";

			    ngcliext:node-fmt "^sequence @{sequence} @{action}";

			    leaf sequence {
				type uint32;
				description
				    "Rules are executed in increasing sequence
				     number.";
			    }

			    leaf action {
				type community-list-action;
				description
				    "One of the actions 'deny', 'permit'.";
			    }

			    choice community-value {
				description
				    "The Community value.  A standard community
				     value can be one of <ASN>:<policy>,
				     'internet', 'no-export', 'local-AS',
				     'no-advertise', or.  With 'extended',
				     <ip-address>:<policy> is also allowed.
				      An expanded value is a regular
				      expression.";

				case community {
				    description
					"The Community value.  A standard
					 community value can be one of
					 <ASN>:<policy>, 'internet',
					 'no-export', 'local-AS',
					  'no-advertise'";

				    leaf community {
					type string;
					ngcliext:node-fmt "$< @@$n";
				    }
				}

				case rt-value {
				    leaf rt {
					type string {
					    pattern "[0-9]+:[0-9]+";
					}
					description
					    "Route Target Extcommunity value
					     rt value1:value2.";
					ngcliext:node-fmt "$< $% @@$n";
				    }
				}

				case soo-value {
				    leaf soo {
					type string {
					    pattern "[0-9]+:[0-9]+";
					}
					description
					    "Source of Origin Extcommunity
					     value soo value1:value2.";
					ngcliext:node-fmt "$< $% @@$n";
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

    augment "/ngrt:route-config/ngrt:dynamic/ngfrr:route-maps/ngfrr:map/ngfrr:rules/ngfrr:rule/ngfrr:match" {

        leaf as-path-name {
	    type leafref {
		path "/ngrt:route-config"
		    + "/ngrt:dynamic"
		    + "/ngbgp:bgp"
		    + "/ngbgp:as-path-table"
		    + "/ngbgp:as-path"
		    + "/ngbgp:name";
	    }
	    description
		"The name of an as-path entry.";
	    ngcliext:node-fmt "$< as-path @@$n";
	}

	container community {
	    description
		"Match community list.";

	    ngcliext:parent-fmt "$< $%";

	    leaf comm-list-name {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:community-lists"
			+ "/ngbgp:community"
			+ "/ngbgp:name";
		}
		description
		    "The name of a community list.";
		ngcliext:node-fmt "$< @@%{exact-match}$n";
	    }

	    leaf exact-match {
		type boolean;
		description
		    "If matching a community list,
		     it may be specified as an
		     exact match.";
		ngcliext:sibling-op "bool";
		ngcliext:sibling-fmt "| $%";
	    }
	}

	container extcommunity {
	    description
		"Match extended community list.";

	    ngcliext:parent-fmt "$< $%";

	    leaf extcomm-list-name {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:community-lists"
			+ "/ngbgp:community"
			+ "/ngbgp:name";
		}
		description
		    "The name of an extended
		     community list.";
		ngcliext:node-fmt "$< @@$n";
	    }
	}

	container large-community {
	    description
		"Match large community list.";

	    ngcliext:parent-fmt "$< $%";

	    leaf large-comm-list-name {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:community-lists"
			+ "/ngbgp:community"
			+ "/ngbgp:name";
		}
		description
		    "The name of a large
		     community list.";
		ngcliext:node-fmt "$< @@$n";
	    }
	}

	leaf peer-ip-address {
	    type leafref {
		path "/ngrt:route-config/ngrt:dynamic"
		    + "/ngbgp:bgp/ngbgp:routers"
		    + "/ngbgp:router/ngbgp:neighbors"
		    + "/ngbgp:neighbor/ngbgp:peer";
	    }
	    description
		"The peer IP address is matched.";
	    ngcliext:node-fmt "$< peer @@$n";
	}
    }

    augment "/ngrt:route-config/ngrt:dynamic/ngfrr:route-maps/ngfrr:map/ngfrr:rules/ngfrr:rule/ngfrr:set" {

	container as-path {
	    description
		"Group as-path related attributes.";

	    ngcliext:parent-fmt "$< $%";

	    leaf exclude {
		type string;
		description
		    "Exclude this set of AS numbers.";
		ngcliext:node-fmt "$< $% @@$n";
	    }

	    leaf prepend {
		type string;
		description
		    "Prepend this set of AS numbers.";
		ngcliext:node-fmt "$< $% @@$n";
	    }

	    leaf last-as {
		type uint32;
		description
		    "Prepend the leftmost ASN to the
		     AS_PATH.";
		ngcliext:node-fmt "$< $% @@$n";
	    }
	}

	leaf atomic-aggregate {
	    type boolean;
	    description
		"BGP atomic-aggregate attribute.";
	    ngcliext:node-op "bool";
	    ngcliext:node-fmt "|$< $%$n";
	}

	container community {
	    description
		"Configuration to set community.";

	    ngcliext:parent-fmt "$< $%";

	    leaf none {
		type boolean;
		description
		    "Remove the community values from
		     the update.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|$< $%$n";
	    }

	    leaf value {
		type string;
		description
		    "The existing BGP community values are
		     replaced with this community value.";
		ngcliext:node-fmt "$< $q@@$q%{additive}$n";
	    }

	    leaf additive {
		type boolean;
		description
		    "Rather than replacing the existing
		     community values, this community
		     value is appended to the existing
		     set.";
		ngcliext:sibling-op "bool";
		ngcliext:sibling-fmt "| $%";
	    }
	}

	container community-list {
	    description
		"Configuration for community-lists.";

	    ngcliext:parent-fmt "$< comm-list";

	    leaf delete {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:community-lists"
			+ "/ngbgp:community"
			+ "/ngbgp:name";
		}
		description
		    "The community values from the given
		     Community List are removed from the
		     BGP update.";
		ngcliext:node-fmt "$< @@ $%$n";
	    }
	}

	container extcommunity {
	    description
		"Configuration for extcommunity values.";

	    ngcliext:parent-fmt "$< $%";

	    choice ext-value {
		case rt-value {
		    leaf rt {
			type string {
			    pattern "[0-9]+:[0-9]+";
			}
			description
			    "Route Target Extcommunity
			     value rt value1:value2.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}

		case soo-value {
		    leaf soo {
			type string {
			    pattern "[0-9]+:[0-9]+";
			}
			description
			    "Source of Origin Extcommunity
			     value soo value1:value2.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}
	    }
	}

	container large-community {
	    description
		"Information about large communities.";

	    ngcliext:parent-fmt "$< $%";

	    leaf none {
		type boolean;
		description
		    "Large community list.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|$< $%$n";
	    }

	    leaf value {
		type string;
		description
		    "List of large communities.";
		ngcliext:node-fmt "$< $q@@$q%{additive}$n";
	    }

	    leaf additive {
		type boolean;
		description
		    "Rather than replacing the existing
		     community values, this community
		     value is appended to the existing
		     set.";
		ngcliext:sibling-op "bool";
		ngcliext:sibling-fmt "| $%";
	    }
	}

	container large-comm-list {
	    description
		"Configuration for large-comm-lists.";

	    ngcliext:parent-fmt "$< $%";

	    leaf delete {
		type leafref {
		    path "/ngrt:route-config"
			+ "/ngrt:dynamic"
			+ "/ngbgp:bgp"
			+ "/ngbgp:community-lists"
			+ "/ngbgp:community"
			+ "/ngbgp:name";
		}
		description
		    "The community values from the given
		     Large Communities List are
		     removed from the BGP update.";
		ngcliext:node-fmt "$< @@ $%$n";
	    }
	}
    }

    augment "/ngrt:route-config/ngrt:dynamic/ngfrr:route-maps/ngfrr:map/ngfrr:rules/ngfrr:rule/ngfrr:set/ngfrr:ip/ngfrr:next-hop" {

	leaf use-peer-address {
	    type boolean;
	    description
		"If true, the BGP peer address
		 is used as the next hop.";
	    ngcliext:node-op "bool";
	    ngcliext:node-fmt "|$< peer-address$n";
	}
    }

    augment "/ngrt:route-config/ngrt:dynamic/ngfrr:route-maps/ngfrr:map/ngfrr:rules/ngfrr:rule/ngfrr:set/ngfrr:ipv6/ngfrr:next-hop" {

	leaf use-peer-address {
	    type boolean;
	    description
		"If true, the BGP peer address
		 is use as the next hop.";
	    ngcliext:node-op "bool";
	    ngcliext:node-fmt "|$< peer-address$n";
	}
    }

    augment "/ngrt:route-state/ngrt:dynamic" {

	container bgp {

	    container global-options {
		description
		    "These are options that apply to the BGP Server or
		     to all BGP Router configurations.";

		container debug {
		    description
			"BGP debug options.";

		    container as4 {
			description
			    "AS4 debug action.";

			leaf all {
			    type boolean;
			    description
				"If true, debug AS4 actions.";
			}

			leaf segment {
			    type boolean;
			    description
				"If true, debug AS4 AS-path segment handling.";
			}
		    }

		    container bestpath {
			description
			    "bestpath debug action.";

			leaf ipv6-prefix {
			    type inet:ipv6-prefix;
			    description
				"Debug bestpath of this IPv6 prefix.";
			}
		    }

		    container keepalive {
			description
			    "Debug BGP neighbor keepalive.";

			leaf all {
			    type boolean;
			    description
				"Enable BGP neighbor keepalive debug.";
			}

			leaf peer {
			    type string;
			    description
				"Debug specific BGP neighbor.";
			}
		    }

		    container neighbor-events {
			description
			    "Debug BGP neighbor events.";

			leaf all {
			    type boolean;
			    description
				"Enable BGP neighbor events debug.";
			}

			leaf peer {
			    type string;
			    description
				"Debug specific BGP neighbor.";
			}
		    }

		    leaf nht {
			type boolean;
			description
			    "If true, enable next hop tracking events.";
		    }

		    leaf update-groups {
			type boolean;
			description
			    "If true, update-groups.";
		    }

		    container updates {
			description
			    "Debug BGP neighbor events.";

			leaf all {
			    type boolean;
			    description
				"Debug BGP updates.";
			}

			leaf in-peer {
			    type string;
			    description
				"Debug specific BGP neighbor in-updates.";
			}

			leaf out-peer {
			    type string;
			    description
				"Debug specific BGP neighbor out-updates.";
			}

			leaf prefix {
			    type inet:ip-prefix;
			    description
				"Debug specific BGP IPv4 or IPv6 prefix.";
			}
		    }

		    container zebra {
			description
			    "Debug BGP Zebra messages.";

			leaf all {
			    type boolean;
			    description
				"Debug BGP Zebra messages.";
			}

			leaf prefix {
			    type inet:ip-prefix;
			    description
				"Debug specific BGP IPv4 or IPv6 prefix.";
			}
		    }
		}

		leaf enable {
		    type boolean;
		    default false;
		    description
			"If true, the BGP Daemon is enabled.";
		}

		leaf route-map-delay-timer {
		    type uint16 {
			range "0..600";
		    }
		    description
			"The delay time in seconds before processing
		    route-map changes.";
		}
	    }

	    container routers {
		description
		    "Table of BGP Router instances index by VRF ID.";

		list router {
		    key "vrf-id";

		    description
			"Each router is identified by a VRF ID.";

		    leaf vrf-id {
			type bgp-vrf-id;
			description
			    "The Virtual Routing and Forwrding ID,
			     Each router is identified using the name of
			     a VRF, or the word 'default'.";
		    }

		    leaf asn {
			type uint32 {
			    range "1..4294967295";
			}
			mandatory true;
			description
			    "The BGP Router AS-Number.";
		    }

		    leaf allow-martian-nexthop {
			type boolean;
			description
			    "If true, allow martian next hops.";
		    }

		    leaf always-compare-med {
			type boolean;
			description
			    "Always compare the Multi-exit-discriminator.";
		    }

		    leaf bestpath-as-path-multipath-relax {
			type boolean;
			description
			    "Best path decisions should consider paths of
			     equal AS-path length candidates for multipath
			     computation.  Allow load sharing on routes with
			     different AS-paths of the same length.";
		    }

		    leaf bestpath-as-path-multipath-relax-as-set {
			type boolean;
			description
			    "If true, generate an AS-set.";
		    }

		    leaf bestpath-as-path-confed {
			type boolean;
			description
			    "Best path decisions should be based on the length
			     of confederation path sets.";
		    }

		    leaf bestpath-as-path-ignore {
			type boolean;
			description
			    "Best path decisions should ignore AS-path
			    lengths.";
		    }

		    leaf bestpath-compare-routerid {
			type boolean;
			description
			    "Break otherwise equal route ties using
			    router id.";
		    }

		    container bestpath-med {
			leaf confed {
			    type boolean;
			    description
				"Compare MED attribute among confederation
				 paths.";
			}

			leaf missing-as-worst {
			    type boolean;
			    description
				"Treat a missing MED attribute as the
				 least preferred value.";
			}
		    }

		    leaf client-to-client-reflection {
			type boolean;
			description
			    "Allow client-to-client route reflection.";
		    }

		    leaf cluster-id {
			type union {
			    type inet:ipv4-address-no-zone;
			    type uint32;
			}
			description
			    "The route-reflector cluster id expressed as
			     either an IPv4 address or an unsigned 32-bit
			     integer.";
		    }

		    leaf coalesce-time {
			type uint32;
			description
			    "Subgroup coalesce timer in ms.";
		    }

		    container confederation {
			description
			    "Confederation Parameters.";

			leaf identifier {
			    type uint32;
			    description
				"The confederation identifier; an AS number.";
			}

			container peers {
			    leaf-list peer {
				type uint32 {
				    range "1..4294967295";
				}
				description
				    "A list of AS numbers for each peer.";
			    }
			}
		    }

		    container dampening {
			description
			    "Route flap dampening parameters.";

			leaf enable {
			    type boolean;
			    description
				"Enable route-flap dampening.";
			}

			leaf penalty-half-life {
			    type uint8 {
				range "1..45";
			    }
			    description
				"The penalty half-life value [1-45].";
			}

			leaf route-reuse {
			    type uint16 {
				range "1..20000";
			    }
			    description
				"The route reuse start value.";
			}

			leaf route-suppression {
			    type uint16 {
				range "1..20000";
			    }
			    description
				"The route suppression start value.";
			}

			leaf route-suppression-maximum {
			    type uint8;
			    description
				"The route suppression maximum value.";
			}
		    }

		    leaf deterministic-med {
			type boolean;
			description
			    "Always produce deterministic route-selection by
			     picking the best MED path advertised from the
			     neighboring AS.";
		    }

		    leaf disable-ebgp-connected-route-check {
			type boolean;
			description
			    "Disable checking if nexthop is connected an
			     eBGP session";
		    }

		    leaf listen-limit {
			type uint16 {
			    range "1..5000";
			}
			description
			    "The maximum number of dynamic neighbors that
			     can be created.";
		    }

		    leaf listen-range {
			type string;
			description
			    "An IPv4 or IPv6 prefix range on which listening
			 for dynamic neighbors will take place.";
		    }

		    leaf listen-peer-group-name {
			type string;
			description
			    "The peer group name for dynamically created
			     neighbors.";
		    }

		    container max-med {
			container administrative {
			    presence
				"If present without a specific value,
				 administratively advertise routes with
				 maximum MED for an indefinite period.";

			    leaf med-value {
				type uint32;
				description
				    "The maximum MED value to use.";
			    }
			}

			container on-startup {
			    leaf time-period {
				type uint32;
				description
				    "The time period, in seconds, for
				    max-med.";
			    }

			    leaf med-value {
				type uint32;
				description
				    "The max MED value is effective on
				     startup, and has this time period
				     in seconds.";
			    }
			}
		    }

		    leaf network-import-check {
			type boolean;
			description
			    "If true, check if BGP network route exists
			     in IGP.";
		    }

		    leaf route-reflector-allow-outbound-policy {
			type boolean;
			description
			    "If true, also allow attribure modifications to
			     the route-map-out policy.";
		    }

		    leaf router-id {
			type yang:dotted-quad;
			description
			    "Dotted-quad Id of the router.  Can be any 32-bit
			     unsigned value in dotted-quad format but
			     is usually the IP address of the router.
			     RFC4271 Section 4.2";
		    }

		    container timers {
			description
			    "Various FSM timers.";

			leaf keep-alive {
			    type uint16;
			    description
				"Keepalive interval in seconds. Default is 1/3
				 of the hold-time value.";
			}

			leaf hold-time {
			    type uint16;
			    description
				"Hold-time in seconds. Default 90
				seconds, maybe.";
			}
		    }

		    leaf update-delay-updates {
			type uint16 {
			    range "0..3600";
			}
			description
			    "Force initial delay, [0..3600] seconds, for
			     best-path and updates.  Default 120 seconds.";
		    }

		    leaf update-delay-peer-wait {
			type uint16 {
			    range "1..3600";
			}
			description
			    "Time to wait for a peer to establish connection.
			     Default 120 seconds.";
		    }

		    leaf write-quanta {
			type uint16;
			description
			    "The number of packets to write to peer sockets
			     per update.  Default 10 packets.";
		    }

		    container address-families {
			description
			    "Address-family specific information.";

			container ipv4 {
			    description
				"Address family IPv4 configuration.";

			    container multicast {
				description
				    "Address family IPv4-multicast
				     configuration.";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv4-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv4-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv4-network-announcements;
				}

				leaf table-map {
				    type string;
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				}
			    }

			    container unicast {
				description
				    "Address family IPv4-unicast
				     configuration.";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv4-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv4-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container multiple-path-maximums {
				    description
					"Multi-path maximums.";

				    uses bgp-multiple-path-maximums;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv4-network-announcements;
				}

				container network-imports {
				    description
					"Network imports.";

				    uses bgp-imports;
				}

				container redistributions {
				    description
					"Route redistributions.";

				    uses bgp-redistributions;
				}

				leaf table-map {
				    type string;
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				}
			    }
			}

			container ipv6 {
			    description
				"Address family IPv6 configuration.";

			    container multicast {
				description
				    "Address family IPv6-multicast
				     configuration.";

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv6-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv6-network-announcements;
				}
			    }

			    container unicast {
				description
				    "Address family IPv6-unicast
				     configuration.";

				container aggregations {
				    description
					"Address aggregation.";

				    uses bgp-ipv6-aggregations;
				}

				container distance-admin {
				    description
					"Adminstrative distances.";

				    uses bgp-ipv6-distance-admin;
				}

				container distance-bgp {
				    description
					"BGP distances.";

				    uses bgp-distance-bgp;
				}

				container multiple-path-maximums {
				    description
					"Multi-path maximums.";

				    uses bgp-multiple-path-maximums;
				}

				container neighbors {
				    description
					"BGP neighbors.";

				    uses bgp-neighbors;
				}

				container network-announcements {
				    description
					"Network announcements.";

				    uses bgp-ipv6-network-announcements;
				}

				container network-imports {
				    description
					"Network imports.";

				    uses bgp-imports;
				}

				container redistributions {
				    description
					"Route redistributions.";

				    uses bgp-redistributions;
				}

				leaf table-map {
				    type string;
				    description
					"A route-map to use as a BGP
					 to RIB router download filter.";
				}
			    }
			}
		    }

		    container neighbors {
			description
			    "Table of BGP Neighbors.";

			list neighbor {
			    key "peer";
			    description
				"List of neighbors indexed by peer.";

			    leaf peer {
				type string;
				mandatory true;
				description
				    "The IPv4 or IPv6 address of the
				     neighboring BGP peer, or the name of
				     a peer group.";
			    }

			    leaf advertisement-interval {
				type uint16;
				description
				    "The minimum time in seconds
				     between sending BGP routing
				     updates to this peer.";
			    }

			    leaf bfd {
				type boolean;
				description
				    "Bidirectional Forwarding Detection (BFD)
				     is enabled for this peer.";
			    }

			    container capability-advertise {
				description
				    "This is the set of capabilities that
				     are advertised to this neighbor.";

				leaf dynamic {
				    type boolean;
				    description
					"If true, advertise dynamic capability
					 to this neighbor.";
				}

				leaf extended-nexthop {
				    type boolean;
				    description
					"If true, advertise extended
					 next-hop capability to this
					 neighbor.";
				}
			    }

			    leaf capability-negotiate {
				type boolean;
				default true;
				description
				    "Should neighbor capabilities be
				    negotiated?.";
			    }

			    leaf description {
				type string;
				description
				    "A user description of the neighbor.";
			    }

			    leaf disable-connected-check {
				type boolean;
				description
				    "If true, disable one-hop away EBGP
				     peer using loopback address.";
			    }

			    container ebgp-multihop {
				presence
				    "Allow eBGP neighbors not on directly
				     connected netowrks.";
				description
				    "Control multi-hop neighbors.";

				leaf max-hop-count {
				    type uint8;
				    description
					"Allow neighbors to be
					 multi-hop distant.  Mutually
					 exclusive with 'ttl
					 security'.";
				}
			    }

			    leaf enforce-first-as {
				type boolean;
				description
				    "Enforce the first AS for eBGP routes.";
			    }

			    leaf local-as-number {
				type uint32 {
				    range "1..4294967295";
				}
				description
				    "If present, this value is an alternate
				     AS-number for this BGP instance.
				     Valid for only eBGP peers.";
			    }

			    leaf local-as-no-prepend {
				type boolean;
				description
				    "If true, don't prepend the local-as
				     to the received AS_PATH.
				     Valid for only eBGP peers.";
			    }

			    leaf local-as-replace-as {
				type boolean;
				description
				    "If true, then only the supplied local-as
				     is prepended to the AS_PATH when
				     transmitting local-route updates.
				     Valid for only eBGP peers.";
			    }

			    leaf override-capability {
				type boolean;
				description
				    "A neighbor attribute.";
			    }

			    leaf passive {
				type boolean;
				description
				    "If true, don't send open messages to
				     this neighbor.";
			    }

			    leaf password {
				type string {
				    length "1..63";
				}
				description
				    "The neighbor password.";
			    }

			    leaf peer-group-name {
				type string;
				description
				    "If present, this is the name of a peer
				     group template from which attributes are
				     obtained for this neighbor.";
			    }

			    leaf port {
				type uint16;
				description
				    "IP Port.";
			    }

			    leaf remote-asn {
				type uint32 {
				    range "1..4294967295";
				}
				description
				    "The AS-number of the neighbor.";
			    }

			    leaf enable {
				type boolean;
				description
				    "If true, the neighbor interface
				    is enabled.";
			    }

			    leaf solo {
				type boolean;
				description
				    "If true, the neighbor is part of its
				     own update group.";
			    }

			    leaf strict-capability-match {
				type boolean;
				description
				    "Capabilites should be matched strictly.";
			    }

			    container timers {
				description
				    "Various FSM timers per neighbor.";

				leaf connect {
				    type uint16;
				    description
					"BGP Connection timer.";
				}

				leaf keep-alive {
				    type uint16;
				    description
					"Keepalive interval in
					 seconds. Default is 1/3 of the
					 hold-time value.";
				}

				leaf hold-time {
				    type uint16;
				    description
					"Hold-time in seconds. Default 90
					 seconds, maybe.";
				}
			    }

			    leaf ttl-security-hops {
				type uint8 {
				    range "1..254";
				}
				description
				    "Limit neighbors to being exactly <n-hops>
				     distant.	Mutually exclusive with the
				     'ebgp-multihop' option.";
			    }

			    leaf update-source {
				type string;
				description
				    "The source from which updates will come.
				     It is either an if-name or ipv4-address.";
			    }
			}
		    }
		}
	    }

	    container as-path-table {
		description
		    "Table of AS Paths, indexed by name.  Each entry
		     contains a single regular expression pattern.";

		list as-path {
		    key "name";
		    description
			"AS Path name.";

		    leaf name {
			type string;
			mandatory true;
			description
			    "The AS Path name as supplied by the developer.
			     It is a unique name used to identify this
			     regular expression pattern.";
		    }

		    container patterns {
			description
			    "Each AS Path can have multiple, ordered
			     policy and regular expression patterns pairs.";

			list pattern {
			    key sequence;
			    description
				"The set of ordered patterns and policy pairs
				 for an AS-path.";

			    leaf sequence {
				type uint32;
				description
				    "Pattern order is explicitly managed.";
			    }

			    leaf policy {
				type frr:as-path-policy;
				description
				    "One of the policies 'deny', 'permit'.";
			    }

			    leaf regex {
				type string;
				description
				    "The AS Path regular expression pattern.";
			    }
			}
		    }
		}
	    }

	    container community-lists {
		description
		    "Table of Community Lists, indexed by name.	 Each entry
		     contains a set of rules ordered by sequence number.";

		list community {
		    key "name";
		    description
			"Community List entries indexed by name.";

		    leaf name {
			type string;
			mandatory true;
			description
			    "The Community List name as supplied by
			     the developer.  It is a unique name used
			     to identify this set of Community List
			     Rules.";
		    }

		    leaf description {
			type string;
			description
			    "A user description of the community list.";
		    }

		    leaf value-type {
			type community-list-value-type;
			description
			    "One of 'standard' or 'expanded'.
			     If 'standard' the rules are normal numbers.
			     If 'expanded', the rules are regular
			     expressions.";
		    }

		    leaf value-size {
			type community-list-value-size;
			default "normal";
			description
			    "Optionally one of 'normal', 'extended' or 'large'.
			     When 'normal', the default, rules allow
			     the original, normal communities values.
			     When 'extended', rules allow IPv4-based policies
			     and matches 8 octets per community from RFC 5668.
			     When 'large', rules allow 12-octet values
			     from RFC 8092.";
		    }

		    container rules {
			description
			    "Community List Rule Table ordered by sequence
			     number.";

			list rule {
			    key "sequence";
			    description
				"A set of Community List Rules.";

			    leaf sequence {
				type uint32;
				description
				    "Rules are executed in increasing sequence
				     number.";
			    }

			    leaf action {
				type community-list-action;
				description
				    "One of the actions 'deny', 'permit'.";
			    }

			    leaf community {
				type string;
				description
				    "The Community value.  A standard community
				     value can be one of <ASN>:<policy>,
				     'internet', 'no-export', 'local-AS',
				     'no-advertise', or.  With 'extended',
				     <ip-address>:<policy> is also allowed.
				      An expanded value is a regular
				      expression.";
			    }
			}
		    }
		}
	    }
	}
    }
}
