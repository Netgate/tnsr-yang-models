module netgate-vpf {

    yang-version 1.1;

    namespace "urn:netgate:xml:yang:netgate-vpf";
    prefix "ngvpf";

    import clixon-lib {
	prefix "cl";
    }

    import ietf-inet-types {
	prefix "inet";
    }

    import netgate-cli-extensions {
	prefix "ngcliext";
    }

    import netgate-common {
	prefix "ngcom";
    }

    import netgate-route-table {
	prefix "ngrttab";
    }

    organization "Netgate";

    contact "Web: <http://www.netgate.com>";

    description
	"This YANG module provides a Netgate-defined data-model
	 for Netbsd Packet Filters.

	 Copyright 2024, 2025 Rubicon Communications, LLC.";

    revision 2025-02-02 {
	description
	    "TNSR Release 25.02.";
    }

    revision 2024-10-04 {
	description
	    "TNSR Release 24.10.";
    }

    typedef vpf-nat-direction {
	type enumeration {
	    enum in {
		value 1;
		description "Inbound destination translation on packet receive.";

	    }

	    enum out {
		value 2;
		description "Outbound source translation on packet transmit.";
	    }
	}
    }

    typedef vpf-filter-direction {
	type enumeration {
	    enum in {
		value 1;
		description "Inbound filter on packet receive.";
	    }

	    enum out {
		value 2;
		description "Outbound filter on packet transmit.";
	    }

	    enum both {
		value 3;
		description "Filter applied to packets in both directions.";
	    }
	}
    }

    typedef vpf-nat-algorithm {
	type enumeration {
	    enum one-to-one {
		description
		    "Use static 1:1 mapping.";
	    }

	    enum netmap {
		description
		    "Network address mapping from one segment to another,
		     leaving the host part as-is.  The new address is
		     computed as following:
			 addr = net-addr | (orig-addr & ~mask).";
	    }

	    enum "ip-hash" {
		description
		    "The translation address for a new connection is
		     selected based on a hash of the original source
		     and destination addresses.  This algorithms
		     attempts to keep all connections of particular
		     client associated with the same translation address.
		     This is the default algorithm.";
	    }

	    enum "round-robin" {
		description
		    "The translation address for each new connection is
		     selected on a round-robin basis.";
	    }

	    enum "npt66" {
		description
		    "IPv6-to-IPv6 network prefix translation (NPTv6).";
	    }
	}
    }

    grouping vpf-endpoint {
	description
	    "VPF source or destination endpoint";

	leaf inverted {
	    type boolean;
	    description
		"If true, endpoint matching is inverted.";
	    ngcliext:node-op "bool";
	    ngcliext:node-fmt "|$< $%$n";
	}

	choice type {
	    description
		"VPF source or destination endpoint IP addresses";

	    case ipv4-prefix {
		leaf ipv4-prefix {
		    type inet:ipv4-prefix;
		    ngcliext:node-fmt "$< $% @@$n";
		}
	    }

	    case ipv6-prefix {
		leaf ipv6-prefix {
		    type inet:ipv6-prefix;
		    ngcliext:node-fmt "$< $% @@$n";
		}
	    }

	    case table-name {
		leaf table-name {
		    type leafref {
			path "/ngvpf:vpf-config"
			    + "/ngvpf:prefix-tables"
			    + "/ngvpf:table"
			    + "/ngvpf:name";
		    }
		    ngcliext:node-fmt "$< table @@$n";
		}
	    }

	    case if-name {
		leaf if-name {
		    type ngcom:if-identifier-63;
		    ngcliext:node-fmt "$< ifaddrs @@$n";
		}
	    }
	}

	leaf port-min {
	    type uint16;
	    description
		"The first source port in a range.";
		ngcliext:node-fmt "$< port @@%{port-max}$n";
	}

	leaf port-max {
	    type uint16;
	    description
		"The last source port in a range.";
	    ngcliext:sibling-fmt " @@";
	}
    }

    grouping vpf-match-base {
	description
	    "The packet attributes to match in an VPF rule.";

	container from {
	    description
		"The source pattern to match in an VPF rule.";

	    ngcliext:parent-fmt "^from";

	    uses vpf-endpoint;
	}

	container to {
	    description
		"The destination pattern to match in an VPF rule.";

	    ngcliext:parent-fmt "^to";

	    uses vpf-endpoint;
	}

	leaf protocol-set {
	    type ngcom:ip-protocol-name-or-number-set;
	    description
		"A set of IP protocol names or numbers.";
	    ngcliext:node-fmt "^protocol @@$n";
	}

	leaf tcp-flags-mask {
	    type ngcom:tcp-flags;
	    description
		"The TCP flags mask as a set of names.";
	    ngcliext:node-fmt "^tcp flags mask $q@@$q$n";
	}

	leaf tcp-flags-value {
	    type ngcom:tcp-flags;
	    description
		"The TCP flags value as a set of flags names.";
	    ngcliext:node-fmt "^tcp flags value $q@@$q$n";
	}

	leaf icmp-type {
	    type uint8;
	    description
		"The ICMP type.";
		ngcliext:node-fmt "^icmp type @@$n";
	}

	leaf icmp-code {
	    type uint8;
	    description
		"The ICMP code.";
		ngcliext:node-fmt "^icmp code @@$n";
	}
    }

    grouping vpf-match-config {

	uses vpf-match-base;

	leaf dest-route-table {
	    type leafref {
		path "/ngrttab:route-table-config" +
		     "/ngrttab:static-routes" +
		     "/ngrttab:route-table/ngrttab:name";
	    }
	    description
		"Name of destination VRF for 'in' filter and NAT rules. " +
		"Allows input filter rule flow to match return traffic. " +
		"Allows input NAT rule to direct packets to specific VRF.";
	    ngcliext:node-fmt "^$% @@$n";
	}
    }

    grouping vpf-match-state {

	uses vpf-match-base;

	leaf dest-route-table {
	    type ngcom:rt-identifier-15;
	    description
		"Name of destination VRF for 'in' filter and NAT rules. " +
		"Allows input filter rule flow to match return traffic. " +
		"Allows input NAT rule to direct packets to specific VRF.";
	}
    }


    container "vpf-config" {
	description
	    "VPP Packet Filter (VPF) data needed to support VPP.
	     It consists of a set of named tables containing IP prefixes,
	     a set of named filtering rules, and a set of named NAT rules.";

	ngcliext:parent-fmt "vpf";

	container prefix-tables {
	    description
		"Tables of named IP prefix lists.";

	    ngcliext:parent-fmt "$< table";
	    ngcliext:post-node-fmt "$n";

	    list table {
		key "name";

		ngcliext:node-fmt "$< @{name}$n";
		ngcliext:pre-children-op "push";

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of an IP prefix table.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A text description of the VPF prefix table.";
		    ngcliext:node-fmt "^description @@$n";
		    cl:ignore-compare;
		}

		container prefixes {
		    description
			"A named set of IP prefixes.";

		    list prefix {
			key "ip-prefix";
			ngcliext:post-child-fmt "$n";

			leaf ip-prefix {
			    type inet:ip-prefix;
			    description
				"Either an IPv4 or IPv6 prefix.";
			    ngcliext:node-fmt "^prefix @@";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF prefix table entry.";
			    ngcliext:node-fmt " description @@";
			    cl:ignore-compare;
			}
		    }
		}
	    }
	}

	container filter-rulesets {
	    description
		"A list of named VPF filter rulesets.";

	    ngcliext:parent-fmt "$< filter";
	    ngcliext:post-node-fmt "$n";

	    list ruleset {
		key name;

		ngcliext:node-fmt "$< $% @{name}$n";
		ngcliext:pre-children-op "push";

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of the filter ruleset.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A user description of the VPF filter ruleset.";
		    ngcliext:node-fmt "^$% @@$n";
		    cl:ignore-compare;
		}

		container rules {
		    description
			"A list of filter rules within a ruleset
			 ordered by sequence number.";

		    list rule {
			key sequence;

			ngcliext:node-fmt "^$% @{sequence}$n";
			ngcliext:pre-children-op "push";

			leaf sequence {
			    type uint32;
			    description
				"The VPF filter rule sequence number.";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF filter rule.";
			    ngcliext:node-fmt "^$% @@$n";
			    cl:ignore-compare;
			}

			container filter {
			    uses vpf-match-config;

			    must 'not(child::node()/ipv4-prefix and child::node()/ipv6-prefix)' {
				error-message
				    "Address family must be identical for " +
				    "source and destination prefix on " +
				    "filter rules.";
			    }

			}

			leaf ip-version {
			    type ngcom:ip-address-family;
			    description
				"Indicates the IP version (ipv4 or ipv6)
				 applicable to this VPF rule";
			    ngcliext:node-fmt "^$% @@$n";
			}

			leaf pass {
			    type boolean;
			    description
				"If true, the packet is passed, else blocked.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf tentative {
			    type boolean;
			    description
				"If this rule is matched, ruleset examination
				 continues and this rule is applied only if
				 there is no other rule to apply. If there
				 is one, then this rule’s match is ignored
				 and the other rule takes preference.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf stateful {
			    type boolean;
			    description
				"Create a stateful connection entry upon
				 match.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf vrf-bound {
			    type boolean;
			    description
				"Associate stateful connection entry with " +
				"VRF of outbound interface instead of " +
				"interface index.";
			    must "current() = 'false' or ../stateful = 'true'" {
				error-message
				    "Filter Rule must be stateful to use " +
				    "vrf-bound state";
			    }
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf return-rst {
			    type boolean;
			    description
				"Return a TCP reset on match.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf return-icmp {
			    type boolean;
			    description
				"Return an ICMP error on match (Destination
				 Unreachable/Administratively Prohibited).";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf direction {
			    type vpf-filter-direction;
			    default both;
			    description
				"One of 'in', 'out', or 'both'.";
			    ngcliext:node-fmt "^$% @@$n";
			}
		    }
		}
	    }
	}

	container nat-rulesets {
	    description
		"A list of VPF NAT rulesets.";

	    ngcliext:parent-fmt "$< nat";
	    ngcliext:post-node-fmt "$n";

	    list ruleset {
		key name;

		ngcliext:node-fmt "$< $% @{name}$n";
		ngcliext:pre-children-op "push";

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of the NAT ruleset.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A user description of the VPF NAT ruleset.";
		    ngcliext:node-fmt "^$% @@$n";
		    cl:ignore-compare;
		}

		container rules {
		    description
			"A list of NAT rules within a ruleset
			 ordered by sequence number.";

		    list rule {
			key sequence;

			ngcliext:node-fmt "^$% @{sequence}$n";
			ngcliext:pre-children-op "push";

			leaf sequence {
			    type uint32;
			    description
				"The VPF NAT rule sequence number.";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF NAT rule.";
			    ngcliext:node-fmt "^$% @@$n";
			    cl:ignore-compare;
			}

			container match {
			    uses vpf-match-config;

			    must 'not(child::node()/ipv4-prefix and child::node()/ipv6-prefix)' {
				error-message
				    "Address family must be identical for " +
				    "source and destination prefix on NAT " +
				    "rules.";
			    }
			}

			leaf dynamic {
			    type boolean;
			    description
				"Dynamic mapping.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf no-port-translation {
			    type boolean;
			    description
				"No port translation.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}

			leaf algorithm {
			    type vpf-nat-algorithm;
			    default ip-hash;
			    description
				"One of one-to-one, netmap, ip hash, round robin,
				 or npt66.";
			    ngcliext:node-fmt "^$% @@$n";
			}

			leaf direction {
			    type vpf-nat-direction;
			    description
				"One of 'in' or 'out'.";
			    ngcliext:node-fmt "^$% @@$n";
			}

			container translation {
			    description
				"NAT translation information.";

			    leaf port {
				type uint16;
				description
				    "Port to use for translation.
				     0 means no port.";
				ngcliext:node-fmt "^nat-port @@$n";
			    }

			    choice translation-type {
				case interface {
				    leaf if-name {
					type ngcom:if-identifier-63;
					description
					    "Use IF addresses for
					     translation.";
					ngcliext:node-fmt "^nat-interface @@$n";
				    }
				}

				case prefix {
				    leaf prefix {
					 type inet:ip-prefix;
					 description
					     "Translation prefix.";
					ngcliext:node-fmt "^nat-prefix @@$n";
				    }
				}

				case table-name {
				    leaf table-name {
					type leafref {
					    path "/ngvpf:vpf-config/ngvpf:prefix-tables/ngvpf:table/ngvpf:name";
					}
					description
					    "Translation table name.";
					ngcliext:node-fmt "^nat-table @@$n";
				    }
				}
			    }
			}

			leaf dest-route-table {
			    type leafref {
				path "/ngrttab:route-table-config" +
				     "/ngrttab:static-routes" +
				     "/ngrttab:route-table/ngrttab:name";
			    }
			    description
				"Name of destination VRF for 'in' NAT rule.";
			    ngcliext:node-fmt "^$% @@$n";
			}

			leaf vrf-bound {
			    type boolean;
			    description
				"Associate stateful connection entry with " +
				"VRF of outbound interface instead of " +
				"interface index.";
			    must "current() = 'false' or ../dynamic = 'true'" {
				error-message
				    "NAT Rule must be dynamic to use " +
				    "vrf-bound state";
			    }
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "|^$%$n";
			}
		    }
		}
	    }
	}

	container options {
	    description
		"VPF interface configuration and enablement options.";

	    ngcliext:node-fmt "$< $%$n";
	    ngcliext:pre-children-op "push";
	    ngcliext:post-node-fmt "$n";

	    container startup {
		description
		    "Startup options.";

		container max-connections-per-thread {
		    description
			"Maximum connections per thread.";

		    ngcliext:parent-fmt "^$^ $%";

		    leaf ip4 {
			type uint32;
			default 131072;
			description
			    "Maximum IPv4 connections per thread.";
			ngcliext:node-fmt "$< $% @@$n";
		    }

		    leaf ip6 {
			type uint32;
			default 32768;
			description
			    "Maximum IPv6 connections per thread.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}

		container port-mapping {
		    description
			"Port mapping.";

		    ngcliext:parent-fmt "^$^ $%";

		    leaf min-port {
			type uint16 {
			    range "1024..65535";
			}
			default 1024;
			description
			    "Lowest port used for port mapping.";
			ngcliext:node-fmt "$< $% @@$n";
		    }

		    leaf max-port {
			type uint16 {
			    range "1024..65535";
			}
			must ". >= ../min-port" {
			    description
				"This value MUST be greater or equal to
				 min-port.";
			}
			default 49151;
			description
			    "Highest port used for port mapping.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}
	    }

	    container runtime {
		description
		    "Runtime options.";

		container drop-options {
		    description
			"Drop packets having IP options.";

		    ngcliext:parent-fmt "^$^ $%";

		    leaf ip4 {
			type boolean;
			default false;
			description
			    "Drop IPv4 packets having IP options.";
			ngcliext:node-fmt "$< $% @@$n";
		    }

		    leaf ip6 {
			type boolean;
			default false;
			description
			    "Drop IPv6 packets having IP options.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}

		container timeouts {
		    description
			"Timeouts.";

		    ngcliext:parent-fmt "^$^ $%";

		    container generic {
			description
			    "Generic timeouts.";

			ngcliext:parent-fmt "$< $%";

			leaf closed {
			    type uint32;
			    units "seconds";
			    default 0;
			    description
				"Closed state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf new {
			    type uint32;
			    units "seconds";
			    default 30;
			    description
				"New state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf established {
			    type uint32;
			    units "seconds";
			    default 60;
			    description
				"Established state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}
		    }

		    container tcp {
			description
			    "TCP timeouts.";

			ngcliext:parent-fmt "$< $%";

			leaf closed {
			    type uint32;
			    units "seconds";
			    default 10;
			    description
				"Closed state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf new {
			    type uint32;
			    units "seconds";
			    default 30;
			    description
				"New state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf established {
			    type uint32;
			    units "seconds";
			    default 86400;
			    description
				"Established state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf half-closed {
			    type uint32;
			    units "seconds";
			    default 21600;
			    description
				"Half-closed state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}

			leaf time-wait {
			    type uint32;
			    units "seconds";
			    default 240;
			    description
				"Time-wait state.";
			    ngcliext:node-fmt "$< $% @@$n";
			}
		    }
		}

		container tcp {
		    description
			"TCP.";

		    ngcliext:parent-fmt "^$^ $%";

		    leaf strict-rst-order {
			type boolean;
			default true;
			description
			    "Enforce strict TCP RST order.";
			ngcliext:node-fmt "$< $% @@$n";
		    }

		    leaf max-ack-win {
			type uint32;
			default 66000;
			description
			    "Maximum TCP ACK window.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}
	    }

	    container interfaces {
		description
		    "The names of filtering and NAT rulesets applied
		     to interfaces.";

		list interface {
		    key "if-name";

		    ngcliext:parent-fmt "^$% @{if-name}";

		    leaf if-name {
			type ngcom:if-identifier-63;
			description
			    "The name of an interface.";
		    }

		    leaf filter-ruleset {
			type leafref {
			    path "/ngvpf:vpf-config"
				+ "/ngvpf:filter-rulesets"
				+ "/ngvpf:ruleset"
				+ "/ngvpf:name";
			}
			description
			    "The name of the filter ruleset on this
			     interface.";
			ngcliext:node-fmt "$< $% @@$n";
		    }

		    leaf nat-ruleset {
			type leafref {
			    path "/ngvpf:vpf-config"
				+ "/ngvpf:nat-rulesets"
				+ "/ngvpf:ruleset"
				+ "/ngvpf:name";
			}
			description
			    "The name of the NAT ruleset on this interface.";
			ngcliext:node-fmt "$< $% @@$n";
		    }
		}
	    }
	}

	container ipfix {
	    description
		"IPFIX exporting options.";

	    ngcliext:node-fmt "$< $%$n";
	    ngcliext:pre-children-op "push";

	    leaf enable {
		type empty;
		description
		    "If present, IPFIX exporting is enabled.";
		ngcliext:node-fmt "^$%$n";
	    }

	    leaf domain {
		type uint32;
		default 1;
		description
		    "Domain ID.";
		ngcliext:node-fmt "^$% @@$n";
	    }

	    leaf src-port {
		type uint16;
		default 4739;
		description
		    "Source port number.";
		ngcliext:node-fmt "^$% @@$n";
	    }
	}

	leaf enable {
	    type empty;
	    description
		"If present, the feature is enabled.";
	    ngcliext:node-fmt "$< $%$n";
	}
    }


    container "vpf-state" {
	config "false";

	description
	    "Netbsd Packet Filter (VPF) state data. It consists of a set of
	     named tables containing IP prefixes, a set of named filtering
	     rules, a set of named NAT rules, and params.";

	container prefix-tables {
	    description
		"Tables of named IP prefix lists.";

	    list table {
		key "name";

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of an IP prefix table.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A text description of the VPF prefix table.";
		}

		container hash-buckets {
		    description
			"Hash buckets.";

		    leaf ip4 {
			type uint32;
			description
			    "IPv4 hash buckets.";
		    }

		    leaf ip6 {
			type uint32;
			description
			    "IPv6 hash buckets.";
		    }
		}

		container prefixes {
		    description
			"Each table is a named set of IP prefixes.";

		    list prefix {
			key "ip-prefix";
			description
			    "A named set of IPv4 and IPv6 prefixes.";

			leaf ip-prefix {
				type inet:ip-prefix;
				description
				    "Either an IPv4 or IPv6 prefix.";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF prefix table entry.";
			}
		    }
		}
	    }
	}

	container filter-rulesets {
	    description
		"A list of named VPF filter rulesets.";

	    list ruleset {
		key name;

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of the filter ruleset.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A user description of the VPF filter ruleset.";
		}

		container rules {
		    description
			"A list of filter rules within a ruleset
			 ordered by sequence number.";

		    list rule {
			key sequence;

			leaf sequence {
			    type uint32;
			    description
				"The VPF filter rule sequence number.";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF filter rule.";
			}

			container filter {
			    uses vpf-match-state;
			}

			leaf ip-version {
			    type ngcom:ip-address-family;
			    description
				"Indicates the IP version (ipv4 or ipv6)
				 applicable to this VPF rule";
			}

			leaf pass {
			    type boolean;
			    description
				"If true, the packet is passed, else blocked.";
			}

			leaf tentative {
			    type boolean;
			    description
				"If this rule is matched, ruleset examination
				 continues and this rule is applied only if
				 there is no other rule to apply. If there
				 is one, then this rule’s match is ignored
				 and the other rule takes preference.";
			}

			leaf stateful {
			    type boolean;
			    description
				"Create a stateful connection entry upon
				 match.";
			}

			leaf vrf-bound {
			    type boolean;
			    description
				"Associate stateful connection entry with " +
				"VRF of outbound interface instead of " +
				"interface index.";
			}

			leaf return-rst {
			    type boolean;
			    description
				"Return a TCP reset on match.";
			}

			leaf return-icmp {
			    type boolean;
			    description
				"Return an ICMP error on match (Destination
				 Unreachable/Administratively Prohibited).";
			}

			leaf direction {
			    type vpf-filter-direction;
			    description
				"One of 'in', 'out', or 'both'.";
			}

			leaf dest-route-table {
			    type ngcom:rt-identifier-15;
			    description
				"Name of destination VRF for 'in' filter " +
				"rule.";
			}
		    }
		}
	    }
	}

	container nat-rulesets {
	    description
		"A list of VPF NAT rulesets.";

	    list ruleset {
		key name;

		leaf name {
		    type ngcom:identifier-63;
		    description
			"The name of the NAT ruleset.";
		}

		leaf description {
		    type ngcom:description-63;
		    description
			"A user description of the VPF NAT ruleset.";
		}

		container rules {
		    description
			"A list of NAT rules within a ruleset
			 ordered by sequence number.";

		    list rule {
			key sequence;

			leaf sequence {
			    type uint32;
			    description
				"The VPF NAT rule sequence number.";
			}

			leaf description {
			    type ngcom:description-63;
			    description
				"A user description of the VPF NAT rule.";
			}

			container match {
			    uses vpf-match-state;
			}

			leaf dynamic {
			    type boolean;
			    description
				"Dynamic mapping.";
			}

			leaf no-port-translation {
			    type boolean;
			    description
				"No port translation.";
			}

			leaf algorithm {
			    type vpf-nat-algorithm;
			    description
				"One of one-to-one, netmap, ip hash, round robin,
				 or npt66.";
			}

			leaf direction {
			    type vpf-nat-direction;
			    description
				"One of 'in' or 'out'.";
			}

			container translation {
			    description
				"NAT translation information.";

			    leaf port {
				type uint16;
				description
				    "Port to use for translation.
				     0 means no port.";
			    }

			    choice translation-type {
				case interface {
				    leaf if-name {
					type ngcom:if-identifier-63;
					description
					    "Use IF addresses for
					     translation.";
				    }
				}

				case table-name {
				    leaf table-name {
					type ngcom:if-identifier-63;
					description
					    "Use Table name for
					     translation.";
				    }
				}

				case prefix {
				    leaf prefix {
					 type inet:ip-prefix;
					 description
					     "Translation prefix.";
				    }
				}
			    }
			}

			leaf dest-route-table {
			    type ngcom:rt-identifier-15;
			    description
				"Name of destination VRF for 'in' NAT rule.";
			}

			leaf vrf-bound {
			    type boolean;
			    description
				"Associate stateful connection entry with " +
				"VRF of outbound interface instead of " +
				"interface index.";
			}
		    }
		}
	    }
	}

	container options {
	    description
		"VPF interface state and enablement options.";

	    container startup {
		description
		    "Startup options.";

		container max-connections-per-thread {
		    description
			"Maximum connections per thread.";

		    leaf ip4 {
			type uint32;
			description
			    "Maximum IPv4 connections per thread.";
		    }

		    leaf ip6 {
			type uint32;
			description
			    "Maximum IPv6 connections per thread.";
		    }
		}

		container port-mapping {
		    description
			"Port mapping.";

		    leaf min-port {
			type uint16;
			description
			    "Lowest port used for port mapping.";
		    }

		    leaf max-port {
			type uint16;
			description
			    "Highest port used for port mapping.";
		    }
		}
	    }

	    container runtime {
		description
		    "Runtime options.";

		container drop-options {
		    description
			"Drop packets having IP options.";

		    leaf ip4 {
			type boolean;
			description
			    "Drop IPv4 packets having IP options.";
		    }

		    leaf ip6 {
			type boolean;
			description
			    "Drop IPv6 packets having IP options.";
		    }
		}

		container timeouts {
		    description
			"Timeouts.";

		    container generic {
			description
			    "Generic timeouts.";

			leaf closed {
			    type uint32;
			    units "seconds";
			    description
				"Closed state.";
			}

			leaf new {
			    type uint32;
			    units "seconds";
			    description
				"New state.";
			}

			leaf established {
			    type uint32;
			    units "seconds";
			    description
				"Established state.";
			}
		    }

		    container tcp {
			description
			    "TCP timeouts.";

			leaf closed {
			    type uint32;
			    units "seconds";
			    description
				"Closed state.";
			}

			leaf new {
			    type uint32;
			    units "seconds";
			    description
				"New state.";
			}

			leaf established {
			    type uint32;
			    units "seconds";
			    description
				"Established state.";
			}

			leaf half-closed {
			    type uint32;
			    units "seconds";
			    description
				"Half-closed state.";
			}

			leaf time-wait {
			    type uint32;
			    units "seconds";
			    description
				"Time-wait state.";
			}
		    }
		}

		container tcp {
		    description
			"TCP.";

		    leaf strict-rst-order {
			type boolean;
			description
			    "Enforce strict TCP RST order.";
		    }

		    leaf max-ack-win {
			type uint32;
			description
			    "Maximum TCP ACK window.";
		    }
		}
	    }

	    container interfaces {
		description
		    "The names of filtering and NAT rulesets applied
		     to interfaces.";

		list interface {
		    key "if-name";

		    leaf if-name {
			type ngcom:if-identifier-63;
			description
			    "The name of an interface.";
		    }

		    leaf filter-ruleset {
			type ngcom:identifier-63;
			description
			    "The name of the filter ruleset on this
			     interface.";
		    }

		    leaf nat-ruleset {
			type ngcom:identifier-63;
			description
			    "The name of the NAT ruleset on this interface.";
		    }
		}
	    }
	}

	container ipfix {
	    description
		"IPFIX exporting options.";

	    leaf enable {
		type boolean;
		description
		    "Indicates whether IPFIX exporting is enabled.";
	    }

	    leaf domain {
		type uint32;
		description
		    "Domain ID.";
	    }

	    leaf src-port {
		type uint16;
		description
		    "Source port number.";
	    }
	}

	leaf enable {
	    type boolean;
	    description
		"Indicates whether the feature is enabled.";
	}
    }
}
