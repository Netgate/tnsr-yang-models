module netgate-ntp {

    yang-version 1.1;

    namespace "urn:netgate:xml:yang:netgate-ntp";
    prefix "ngntp";

    import ietf-inet-types {
	prefix "inet";
    }

    import netgate-cli-extensions {
	prefix "ngcliext";
    }

    import netgate-common {
	prefix "ngcom";
    }

    organization "Netgate";

    contact "Web: <http://www.netgate.com>";

    description
	"This YANG module provides a data-model for the NTP service.

	 Copyright 2018-2025 Rubicon Communications, LLC.
	";

    revision 2025-06-01 {
	description
	    "TNSR Release 25.06.";
    }

    revision 2021-11-15 {
	description
	    "TNSR Release 21.11.";
    }

    revision 2021-02-15 {
	description
	    "TNSR Release 21.02.";
    }

    revision 2020-06-15 {
	description
	    "TNSR Release 20.06.";
    }

    revision 2020-02-15 {
	description
	    "TNSR Release 20.02.";
    }

    revision 2019-05-30 {
	description
	    "TNSR Release 19.05.";
    }

    revision 2019-02-15 {
	description
	    "TNSR Release 19.02.";
    }

    revision 2018-05-17 {
	description
	    "Initial Revision.";
    }

    typedef ntp-server-mode {
	type enumeration {
	    enum server {
		description
		    "Server";
	    }
	    enum pool {
		description
		    "Pool";
	    }
	}
	description
	    "Enumeration of server types.";
    }

    typedef ntp-access-action {
	type enumeration {
	    enum allow {
		description
		    "Allow access.";
	    }
	    enum deny {
		description
		    "Deny access.";
	    }
	}
	description
	    "List of access rule actions.";
    }

    typedef ntp-selection {
	type enumeration {
	    enum "selected" {
		description
		    "selected";
	    }

	    enum "nonselectable" {
		description
		    "cannot be selected";
	    }

	    enum "falsetick" {
		description
		    "discarded by intersection algorithm";
	    }

	    enum "jittery" {
		description
		    "jittery";
	    }

	    enum "unselected" {
		description
		    "unselected";
	    }
	}
    }


    container ntp-config {
	description
	    "Network Time Protocol daemon configuration for time
	     keeping and services.";

	container system {
	    description
		"The NTP system parameters not managed by the daemon.";

	    ngcliext:parent-fmt "ntp";

	    leaf namespace {
		type ngcom:network-namespace;
		description
		    "Network namespace to be used by NTP daemon.";
		ngcliext:node-fmt "$< $% @@$n";
	    }

	    leaf enable {
		type boolean;
		description
		    "If true, the NTP daemon is enabled.";
		ngcliext:node-op "bool";
		ngcliext:node-fmt "|$< $%$n";
	    }
	}

	container daemon {
	    description
		"NTP daemon configuration parameters.";

	    ngcliext:node-fmt "ntp server$n";
	    ngcliext:pre-children-op "push";

	    container parameters {
		description
		    "The NTP parameters managed by the NTP daemon.";

		leaf driftfile {
		    type string;
		    description
			"Full path name of the drift file.  If not specified,
			 /var/lib/chrony/drift.";
		    ngcliext:node-fmt "^$% @@$n";
		}

		leaf maxupdateskew {
		    type decimal64 {
			fraction-digits 3;
		    }
		    description
			"Maximum skew update threshold.";
		    ngcliext:node-fmt "^$% @@$n";
		}

		container disabled-flags {
		    description
			"Force monitor flags to disabled.";

		    ngcliext:parent-fmt "^disable";

		    leaf monitor {
			type boolean;
			description
			    "If true, disable monitor.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf rtcsync {
			type boolean;
			description
			    "If true, disable RTC sync.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf leapsectz {
			type boolean;
			description
			    "If true, disable getting leap second
			     info from the timezone database.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }
		}

		container enabled-flags {
		    description
			"Force monitor flags to enabled.";

		    ngcliext:parent-fmt "^enable";

		    leaf monitor {
			type boolean;
			description
			    "If true, enable monitor.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf rtcsync {
			type boolean;
			description
			    "If true, enable RTC sync.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }

		    leaf leapsectz {
			type boolean;
			description
			    "If true, enable getting leap second
			     info from the timezone database.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|$< $%$n";
		    }
		}
	    }

	    container interfaces {
		description
		    "Interface binding specifications.";

		ngcliext:parent-fmt "interface";

		choice bind-designator {
		    description "Binding spec.";

		    case bindaddress {
			leaf bind {
			    type inet:ipv4-address-no-zone;
			    description "IPv4 address to bind to.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}

			leaf bind6 {
			    type inet:ipv6-address-no-zone;
			    description "IPv6 address to bind to.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}
		    }

		    case binddevice {
			leaf binddevice {
			    type ngcom:if-identifier;
			    description "Interface to bind to.";
			    ngcliext:node-fmt "^$< $% @@$n";
			}
		    }
		}
	    }

	    container log {
		description
		    "Logging options";
		    ngcliext:node-fmt "^$%$n";
		    ngcliext:pre-children-op "push";

		must "*" {
		    error-message "At least one log specifer expected";
		}

		leaf rawmeasurements {
		    type boolean;
		    description
			"Log raw NTP measurements";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf measurements {
		    type boolean;
		    description
			"Log measurements";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf statistics {
		    type boolean;
		    description
			"Log statistics";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf selection {
		    type boolean;
		    description
			"Log source selection";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf tracking {
		    type boolean;
		    description
			"Log changes to the estimate of system's
			 gain or loss rate.";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf rtc {
		    type boolean;
		    description
			"Log RTC information";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf refclocks {
		    type boolean;
		    description
			"Log reference clock measurements";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}

		leaf tempcomp {
		    type boolean;
		    description
			"Log temperature compensation";
		    ngcliext:node-op "bool";
		    ngcliext:node-fmt "|^$%$n";
		}
	    }

	    leaf logdir {
		type string;
		description
		    "Full path name of the log directory.";
		ngcliext:node-fmt "^$% @@$n";
	    }

	    container access-rules {
		description
		    "Access rules";

		list access {
		    description
			"Allow and deny rules for NTP requests.";

		    key "sequence";
		    ngcliext:node-fmt "^access";
		    ngcliext:children-order "sequence action all prefix";

		    leaf sequence {
			type uint32;
			description
			    "The sequence numbers provide an ordering for the
			     list of access commands.";
			ngcliext:node-fmt " $% @@";
		    }

		    leaf action {
			type ntp-access-action;
			mandatory true;

			description "One of the action keywords: allow or deny";
			ngcliext:node-fmt " @@";
		    }

		    choice subject {
			description
			    "Allow/deny for all or for a prefix.";
			mandatory true;

			leaf all {
			    type boolean;
			    description
				"If true, allow access from all addresses.";
			    ngcliext:node-op "bool";
			    ngcliext:node-fmt "| $%$n";
			}

			leaf prefix {
			    type inet:ip-prefix;
			    description
				"If specified, allow access from this subnet.";

			    ngcliext:node-fmt " @@$n";
			}
		    }
		}
	    }

	    container servers {
		list server {
		    key "host";

		    ngcliext:node-fmt "^server @{host}$n";
		    ngcliext:pre-children-op "push";

		    leaf host {
			type inet:host;
			mandatory true;
			description
			    "NTP server IP address or FQDN.";
		    }

		    leaf iburst {
			type boolean;
			description
			    "If true, send a burst of attempts to an
			     unreachable server to speed up acquisition of
			     time synchronization.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf burst {
			type boolean;
			description
			    "If true, send a burst of attempts to an
			     server that did not provide good measurements
			     to speed up acquisition of time synchronization.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf maxpoll {
			type uint8 {
			    range "7..17";
			}
			description
			    "Maximum poll interval expressed as a power of
			     2 in seconds.";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    leaf noselect {
			type boolean;
			description
			    "If true, disable time sync for this server,
			     track stats only.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf operational-mode {
			type ntp-server-mode;
			mandatory true;
			description
			    "One of 'server', or 'pool'.";
			ngcliext:node-fmt "^$% @@$n";
		    }

		    leaf prefer {
			type boolean;
			description
			    "If true, favor this server more than others.";
			ngcliext:node-op "bool";
			ngcliext:node-fmt "|^$%$n";
		    }

		    leaf maxsources {
			type int32;
			description
			    "Desired number of sources to be used from
			     the pool";
			ngcliext:node-fmt "^$% @@$n";
			must "../operational-mode = 'pool'" {
			    error-message "maxsources can only be used for pools";
			}
		    }
		}
	    }

	    container maxchange {
		description
		    "Maxchange options.";

		ngcliext:node-fmt "^maxchange";

		// FIXME: `mandatory true` on leafs makes the
		// container mandatory too, somehow
		must "offset and start and ignore" {
		    error-message "offset, start and ignore must be present";
		}

		leaf offset {
		    type decimal64 {
			fraction-digits 3;
		    }
		    description
			"Maximum clock update offset in seconds.
			 If the offset is greater
			 than this value, the NTP daemon will exit
			 unless start and ignore values prevent it.";
		    ngcliext:node-fmt " offset @@";
		}

		leaf start {
		    type int32;
		    description
			"Number of clock updates after which to
			 begin checking the offset.";
		    ngcliext:node-fmt " start @@";
		}

		leaf ignore {
		    type int32;
		    description
			"Number of times to ignore clock updates
			greater than the offset.";
		    ngcliext:node-fmt " ignore @@$n";
		}
	    }

	    container makestep {
		description
		    "Allow stepping system clock.";

		ngcliext:node-fmt "^makestep";

		// FIXME: `mandatory true` on leafs makes the
		// container mandatory too, somehow
		must "threshold and limit" {
		    error-message "offset, start and ignore must be present";
		}

		leaf threshold {
		    type decimal64 {
			fraction-digits 3;
		    }
		    description
			"Step threshold. The system clock will be stepped
                         if the adjustment is larger than the specified
                         value.";
		    ngcliext:node-fmt " threshold @@";
		}

		leaf limit {
		    type int32;
		    description
			"Number of initial clock updates during which
                         stepping is allowed.";
		    ngcliext:node-fmt " limit @@$n";
		}
	    }

	    container tos {
		description
		    "TOS options.";

		must "orphan" {
		    error-message "'orphan' is expected";
		}

		ngcliext:parent-fmt "^tos";

		leaf orphan {
		    type uint8 {
			range "1..16";
		    }
		    description
			"Orphan stratum in the range 1 through 16.";
		    ngcliext:node-fmt "$< $% @@$n";
		}
	    }
	}
    }

    container ntp-state {
	config false;

	description
	    "Network Time Protocol daemon configuration for time
	     keeping and services.";

	container peers {
	    description
		"Information about the server's peer associations.";

	    list peer {
		key "id";

		leaf id {
		    type uint16;
		    description
			"The peer's association ID.";
		}

		container status {
		    description
			"The decoded peer status.";

		    leaf raw {
			type uint16;
			description
			    "The association's rw hex status value.";
		    }

		    leaf auth-enable {
			type boolean;
			description
			    "If true, authentication is enabled for
			     this association.";
		    }

		    leaf authentic {
			type boolean;
			description
			    "If true, the authetication is considered
			     okay for this association.";
		    }

		    leaf reachable {
			type boolean;
			description
			    "If true, the association is reachable.";
		    }

		    leaf selection {
			type ntp-selection;
			description
			    "One of the NTP peer selections selected,
			     nonselectable, falsetick, jittery, unselected,
			     or selectable.";
		    }
		}

		container variables {
		    description
			"The peer variables of an association.";

		    list variable {
			key "name";

			leaf name {
			    type string;
			    description
				"The name of the variable.  These are
				 named and described in the NTP RFCs.";
			}

			leaf raw {
			    type string;
			    description
				"The raw value returned from the peer.";
			}

			leaf decoded {
			    type string;
			    description
				"If needed, the raw value might be decoded
				 into something more legible.";
			}
		    }
		}
	    }
	}
    }


    rpc ntp-control {
	input {
	    leaf operation {
		type ngcom:service-operation;
		mandatory true;
		description
		    "One of the strings 'start', 'stop', 'restart',
		     or 'status'.";
	    }

	    leaf namespace {
		type ngcom:network-namespace;
		description
		    "Network namespace.";
	    }
	}
	output {
	    leaf stdout {
		type string;
	    }
	}
    }

    rpc ntp-coredump {
	input {
	    leaf operation {
		type ngcom:service-op-enable-disable;
		mandatory true;
		description
		    "One of the strings 'enable', or 'disable'.";
	    }

	    leaf namespace {
		type ngcom:network-namespace;
		description
		    "Network namespace.";
	    }
	}
	output {
	    leaf stdout {
		type string;
	    }
	}
    }

    rpc ntp-config-operation {
	input {
	    leaf request {
		type string;
		description
		    "The operation, 'get-config-file'.";
	    }
	    leaf param {
		type string;
		description
		    "An optional parameter.";
	    }
	}
	output {
	    leaf stdout {
		type string;
	    }
	}
    }
}
